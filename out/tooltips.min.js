var GW2TooltipsV2 = (function (exports) {
    'use strict';

    function newElm(spec, ...inner) {
        const [tag, ...classes] = spec.split('.');
        const el = document.createElement(tag);
        if (classes.length)
            el.classList.add(...classes);
        if (inner.length)
            el.append(...inner);
        return el;
    }
    const IMAGE_CDN = 'https://assets.gw2dat.com/';
    const missingImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHEAAABuCAIAAACfnGvJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAMCSURBVHhe7ZjpkeowEAaJywERD9GQDMGwumyPLj+2XssH+/UPyjMjjVBjUWXf3oJGTnnklEdOeeSUR0555JRHTnnklEdOeeSUR0555JRHTnnklEdOeeSUR0555JRHTnnklEdOeeSUR0555JRHTnnklEdOeeSUR0555JRHTnnklEdOeeSU51inr8d0u02PVwp/xf/MHQvt9Hm/Be7PlMgIHhyzCjn9hNlpc7ebxe9hhNPp8QifpTdfuz9Oe3thjHH6Cndkfv7DWb0/syNbnN8QJuzkZr5q5K+Xk2C6BtbCTDEAZJDTuIfKi0tUKuZgHhBx89P1Zj5rtK4YQzspL43z6RnltFBR5DMVKVhGFPTy3UYBO6vo0GuIMcxpvs1O2gbhei0tbOazRusvmCe+x6nddDtbBA4/LmEFNfN1o57TOD0F5ZIDGOh0CbL91SrqDYZ07iiQ5etGdrxNpGkz9XowQ53GG2Sa7H5rFc095n1W1nzdqOPUXzbXGMVYp1FqlqlVxMCNXEd9kG806t2n87cw2KE4g53mO/fUKrJgxkzp5Ou5Paf//E4wtNPzUelupki+32k8+cZgMDpQ6V9w6ij+UAeee8/fcLovcsojpzxyyiOnPHLKI6c8csqDOx39MH0B5JRHTnmGO00v2uKLi0B8e7E8ghf+7aP5RimyDrC1ga9HPmIXp2ajy95tvEhwUaHJlpaouUandgD7OF3MpHijbrAlf13MmsOwoulQxruzu9NfGLClvtO6QTF2d87mNISWuWT7ZGtUMwJy2nLVKK2YBcqGx3Mmp+XUomQqGUcf9YpT3afZ2BBUoWFpElqYnm7ooY5P9n8a9QRcDz83lfylFdVcJnGoUAfudAjlD+FopM7CNZy27/aTKr2KU4c93Y6jD/gG13F6HeSUR0555JRHTnnklEdOeeSUR0555JRHTnnklEdOeeSUR0555JRHTnnklEdOeeSUR0555JRHTnnklEdOeeSUR0555JRHTnnklEdOeeSUR0555JRHTnnklOb9/gEv6oxxwmIw6QAAAABJRU5ErkJggg==';
    function newImg(src, className, alt) {
        if (typeof src == 'number')
            src = src + '.png';
        const img = document.createElement('img');
        img.src = src ? (src.includes(':') ? src : IMAGE_CDN + src) : missingImage;
        if (className)
            img.classList.add(className);
        img.alt = alt ? alt + ' icon' : 'icon';
        return img;
    }
    function fromHTML(html) {
        const dummy = document.createElement('template');
        dummy.innerHTML = html;
        return dummy.content;
    }
    const GW2Text2HTML = (text, ...formatArgs) => text
        ? text
            .replaceAll(/<c=(#.*?)>(.*?)<\/c>/g, `<span style="color: $1;">$2</span>`)
            .replaceAll(/<c=@(.*?)>(.*?)<\/c>/g, `<span class="gw2-color-$1">$2</span>`)
            .replaceAll('[lbracket]', '[').replaceAll('[rbracket]', ']')
            .replaceAll('[null]', '')
            .replaceAll('\n', '<br />')
            .replaceAll(/%str(\d)%/g, (_, i) => formatArgs[+i - 1] || '')
            .replaceAll('%%', '%')
        : '';
    const resolveInflections = (text, count, character) => text
        .replaceAll('[s]', count > 1 ? 's' : '')
        .replaceAll(/(\S+)\[pl:"(.+?)"]/g, count > 1 ? '$2' : '$1')
        .replaceAll(/(\S+)\[f:"(.+?)"]/g, character.sex == "Female" ? '$2' : '$1');
    function n3(v) { return withUpToNDigits(v, 3); }
    function withUpToNDigits(x, digits) {
        let str = x.toFixed(digits);
        while (str.charAt(str.length - 1) === '0')
            str = str.slice(0, -1);
        if (str.charAt(str.length - 1) === '.')
            str = str.slice(0, -1);
        return str;
    }
    function n3s(v) { return v >= 0 ? '+' + n3(v) : n3(v); }
    function n3ss(v) { return v >= 0 ? '+ ' + n3(v) : '- ' + -n3(v); }
    function drawFractional(value, config) {
        if (!config.showPreciseAbilityTimings) {
            const sign = value < 0 ? '-' : '';
            value = Math.abs(value);
            const index = (Math.min(Math.round((value % 1) * 4), 4));
            let fraction = '';
            switch (index) {
                case 0:
                case 4:
                    {
                        value = Math.round(value);
                        break;
                    }
                case 1: {
                    value = Math.floor(value);
                    fraction = '¼';
                    break;
                }
                case 2: {
                    value = Math.floor(value);
                    fraction = '½';
                    break;
                }
                case 3: {
                    value = Math.floor(value);
                    fraction = '¾';
                    break;
                }
            }
            if (value == 0 && fraction == '') {
                return '0';
            }
            return `${sign}${value > 0 ? value : ''}${fraction}`;
        }
        else {
            return withUpToNDigits(value, 3);
        }
    }
    function formatDuration(value, config) {
        value /= 1000;
        if (value >= 3600)
            return drawFractional(value / 3600, config) + 'h';
        else if (value > 60)
            return drawFractional(value / 60, config) + 'min';
        else
            return drawFractional(value, config) + 's';
    }
    function mapLocale(type) {
        switch (type) {
            case 'ConditionDuration': return 'Condition Duration';
            case 'ConditionDamage': return 'Condition Damage';
            case 'HealingPower': return 'Healing Power';
            case 'BowLong': return 'Longbow';
            case 'BowShort': return 'Shortbow';
            case 'Projectile20': return 'Projectile (20% Chance)';
            case 'MagicFind': return 'Magic Find';
            case 'CritChance': return 'Critical Chance';
            case 'CritDamage': return 'Critical Damage';
            case 'BoonDuration': return 'Boon Duration';
            default: return type;
        }
    }
    function findSelfOrParent(self, selector, depth = 10) {
        let current = self;
        while (current && depth-- > 0 && !current.matches(selector))
            current = current.parentElement;
        if (depth == 0)
            return null;
        return current;
    }
    function joinWordList(words, quoteWords = false) {
        if (quoteWords)
            words = words.map(w => `'${w}'`);
        switch (words.length) {
            case 0: return '';
            case 1: return words[0];
            default:
                const last = words[words.length - 1];
                return words.slice(0, -1).join(', ') + ' and ' + last;
        }
    }
    function IsDevIcon(ico) {
        return ['2141735.png', '2141736.png', '2141737.png'].includes(ico);
    }

    class FakeAPI {
        constructor() {
            this.hsApi = new HSAPI('http://127.0.0.1:3000');
            this.fallback = new HSAPI();
        }
        async bulkRequest(endpoint, ids) {
            try {
                return await this.hsApi.bulkRequest(endpoint, ids);
            }
            catch (ex) {
                console.warn(`[gw2-tooltips] [FakeAPI] error trying to get ep '${endpoint}' from localhost, will try to use the fallback API.\n${ex}`);
                return await this.fallback.bulkRequest(endpoint, ids);
            }
        }
    }
    class HSAPI {
        constructor(baseUrl = 'https://api-v0.hardstuck.gg') {
            this.baseUrl = baseUrl;
        }
        async bulkRequest(endpoint, ids) {
            return fetch(`${this.baseUrl}/${endpoint}?ids=${ids.join(',')}`).then(r => r.json());
        }
    }

    var APIs = /*#__PURE__*/Object.freeze({
        __proto__: null,
        FakeAPI: FakeAPI,
        HSAPI: HSAPI
    });

    class APICache {
        static async ensureExistence(endpoint, initialIds) {
            if (!this.apiImpl) {
                this.apiImpl = new HSAPI();
            }
            let additionalIds = Object.assign({
                skills: new Set(),
                items: new Set(),
                traits: new Set(),
                pets: new Set(),
                'pvp/amulets': new Set(),
                specializations: new Set(),
                itemstats: new Set(),
                palettes: new Set(),
            }, { [endpoint]: new Set(initialIds) });
            const findNextRelevantEndpoint = () => {
                for (const [endpoint, ids] of Object.entries(additionalIds))
                    if (ids.size > 0)
                        return endpoint;
                return undefined;
            };
            let didCollectPalettes = false;
            let currentEndpoint = endpoint;
            let i = 0;
            do {
                if (currentEndpoint == 'palettes')
                    didCollectPalettes = true;
                const storageSet = this.storage[currentEndpoint];
                const request = Array.from(additionalIds[currentEndpoint].values());
                additionalIds[currentEndpoint].clear();
                console.info(`[gw2-tooltips] [API cache] round #${i++} for a ${endpoint} request, currently fetching ${currentEndpoint}. Ids: `, request);
                try {
                    const response = await this.apiImpl.bulkRequest(currentEndpoint, request);
                    const unobtainable = request.filter(id => !response.some(obj => obj.id == id));
                    if (unobtainable.length)
                        console.warn(`[gw2-tooltips] [API cache] Did not receive all requested ${currentEndpoint} ids. missing: `, unobtainable);
                    for (const datum of response) {
                        if (storageSet.has(datum.id))
                            continue;
                        storageSet.set(datum.id, datum);
                        this.collectConnectedIds(datum, additionalIds, didCollectPalettes);
                    }
                }
                catch (ex) {
                    console.error(ex);
                }
            } while ((currentEndpoint = findNextRelevantEndpoint()) && i < 100);
        }
        static collectConnectedIds(datum, connectedIdsStorage, didCollectPalettes) {
            const addFacts = (facts) => {
                for (const fact of facts) {
                    if (fact.type == 'Buff' || fact.type == 'BuffBrief') {
                        if (!this.storage.skills.has(fact.buff))
                            connectedIdsStorage.skills.add(fact.buff);
                    }
                    if (fact.type === 'PrefixedBuffBrief' || fact.type === 'PrefixedBuff') {
                        if (!this.storage.skills.has(fact.prefix))
                            connectedIdsStorage.skills.add(fact.prefix);
                        if (!this.storage.skills.has(fact.buff))
                            connectedIdsStorage.skills.add(fact.buff);
                    }
                }
            };
            if (!didCollectPalettes && 'palettes' in datum)
                for (const palette of datum.palettes) {
                    if (!this.storage.palettes.has(palette))
                        connectedIdsStorage.palettes.add(palette);
                }
            if ('groups' in datum)
                for (const group of datum.groups) {
                    for (const candidate of group.candidates) {
                        if (!this.storage.skills.has(candidate.skill))
                            connectedIdsStorage.skills.add(candidate.skill);
                    }
                }
            if ('related_skills' in datum) {
                for (const subSkill of datum.related_skills)
                    if (!this.storage.skills.has(subSkill))
                        connectedIdsStorage.skills.add(subSkill);
            }
            if ('ambush_skills' in datum) {
                for (const subSkill of datum.ambush_skills)
                    if (!this.storage.skills.has(subSkill.id))
                        connectedIdsStorage.skills.add(subSkill.id);
            }
            if ('bundle_skills' in datum) {
                for (const subSkill of datum.bundle_skills)
                    if (!this.storage.skills.has(subSkill))
                        connectedIdsStorage.skills.add(subSkill);
            }
            if ('blocks' in datum)
                for (const block of datum.blocks) {
                    if (block.facts)
                        addFacts(block.facts);
                }
            if ('override_groups' in datum) {
                for (const { blocks } of datum.override_groups)
                    if (blocks)
                        for (const block of blocks)
                            if (block.facts)
                                addFacts(block.facts);
            }
            if ('attribute_set' in datum) {
                if (!this.storage.itemstats.has(datum.attribute_set))
                    connectedIdsStorage.itemstats.add(datum.attribute_set);
            }
            if ('skills' in datum)
                for (const subSkillId of datum.skills) {
                    if (!this.storage.skills.has(subSkillId))
                        connectedIdsStorage.skills.add(subSkillId);
                }
            if ('skills_ai' in datum)
                for (const subSkillId of datum.skills_ai) {
                    if (!this.storage.skills.has(subSkillId))
                        connectedIdsStorage.skills.add(subSkillId);
                }
            if ('skills_soulbeast' in datum)
                for (const subSkillId of datum.skills_soulbeast) {
                    if (!this.storage.skills.has(subSkillId))
                        connectedIdsStorage.skills.add(subSkillId);
                }
            if ('specialization' in datum) {
                if (!this.storage.specializations.has(datum.specialization))
                    connectedIdsStorage.specializations.add(datum.specialization);
            }
            if ('applies_buff' in datum) {
                if (!this.storage.skills.has(datum.applies_buff.buff))
                    connectedIdsStorage.skills.add(datum.applies_buff.buff);
            }
        }
    }
    APICache.storage = {
        skills: new Map(),
        items: new Map(),
        traits: new Map(),
        pets: new Map(),
        'pvp/amulets': new Map(),
        specializations: new Map(),
        itemstats: new Map(),
        palettes: new Map(),
    };
    window.APICache = APICache;

    function recomputeAttributesFromMods(context, weaponSet) {
        const attributeOrder = [
            'Power', 'Toughness', 'Vitality', 'Precision', 'Ferocity', 'ConditionDamage', 'Expertise', 'Concentration', 'HealingPower', 'AgonyResistance',
            'Health', 'Armor', 'ConditionDuration', 'BoonDuration', 'CritChance', 'CritDamage',
        ];
        const stats = context.character.stats;
        const weaponStats = context.character.statsWithWeapons[weaponSet !== null && weaponSet !== void 0 ? weaponSet : context.character.selectedWeaponSet];
        const allParts = {};
        const stage1Attributes = {};
        const stage2Attributes = {};
        let fakeAttributes = stage1Attributes;
        for (const attribute of attributeOrder) {
            const { baseAttribute, suffix, base, div } = getAttributeInformation(attribute, context.character);
            let value = base, text;
            const displayMul = suffix ? 100 : 1;
            const parts = [];
            const sources = stats.sources[attribute].concat(weaponStats.sources[attribute]);
            allParts[attribute] = { parts, sources };
            {
                text = `${n3(base * displayMul) + suffix} base value`;
                if (base) {
                    text += ' from lvl 80';
                }
                parts.push(newElm('div.detail', text));
                if (baseAttribute) {
                    const baseAttrValue = stage1Attributes[baseAttribute];
                    let attrValue = baseAttrValue;
                    if (attribute == 'CritChance')
                        attrValue -= 1000;
                    const statBonus = attrValue / div;
                    value += statBonus;
                    if (statBonus) {
                        text = ` +${n3(statBonus * displayMul) + suffix} from ${n3(baseAttrValue)} ${mapLocale(baseAttribute)}`;
                        if (div != 1)
                            text += ` / ${div / displayMul} (attrib. specific conv. factor)`;
                        parts.push(newElm('div.detail', text));
                    }
                }
            }
            let modValue = 0;
            for (const source of sources.filter(s => !s.modifier.flags.includes('FormatPercent'))) {
                const mod = calculateModifier(source.modifier, context.character.level, fakeAttributes) * source.count;
                modValue += mod;
                text = ` +${n3(mod)} from `;
                if (source.count > 1)
                    text += `${source.count} `;
                text += source.source;
                parts.push(newElm('div.detail', fromHTML(resolveInflections(text, source.count, context.character))));
            }
            value += modValue;
            stage1Attributes[attribute] = value;
        }
        for (const attribute of attributeOrder) {
            const { parts, sources } = allParts[attribute];
            let modValue = 0;
            for (const source of sources.filter(s => s.modifier.flags.includes('FormatPercent') && s.modifier.source_attribute)) {
                const mod = calculateModifier(source.modifier, context.character.level, fakeAttributes) * source.count;
                modValue += Math.round(mod);
                let text = ` +${n3(mod)} (${n3(source.modifier.base_amount)}% of ${source.modifier.source_attribute}) from `;
                if (source.count > 1)
                    text += `${source.count} `;
                text += source.source;
                parts.push(newElm('div.detail', fromHTML(resolveInflections(text, source.count, context.character))));
            }
            stage2Attributes[attribute] = stage1Attributes[attribute] + modValue;
        }
        fakeAttributes = stage2Attributes;
        for (const attribute of attributeOrder) {
            const { suffix, cap } = getAttributeInformation(attribute, context.character);
            let value = stage2Attributes[attribute], text;
            const { parts, sources } = allParts[attribute];
            const displayMul = suffix ? 100 : 1;
            for (const source of sources.filter(s => s.modifier.flags.includes('FormatPercent') && !s.modifier.source_attribute)) {
                const mod = calculateModifier(source.modifier, context.character.level, fakeAttributes) * source.count / 100;
                const toAdd = suffix ? mod : value * mod;
                value += toAdd;
                text = ` +${n3(toAdd * displayMul)}${suffix}`;
                if (!suffix)
                    text += ` (${n3(mod * 100)}%)`;
                text += ' from ';
                if (source.count > 1)
                    text += `${source.count} `;
                text += source.source;
                parts.push(newElm('div.detail', fromHTML(resolveInflections(text, source.count, context.character))));
            }
            const uncappedValue = value;
            stage2Attributes[attribute] = value = Math.min(uncappedValue, cap - 1);
            if (uncappedValue != value)
                parts.push(newElm('span.detail.capped', `(Capped to ${n3(value * displayMul)}${suffix}! Uncapped value would be ${n3(uncappedValue * displayMul)}${suffix})`));
            parts.unshift(newElm('tet.title', newElm('teb', ' +' + n3(value * displayMul) + suffix + ' ' + mapLocale(attribute))));
        }
        for (const attribute of attributeOrder) {
            weaponStats.values[attribute] = stage2Attributes[attribute];
            weaponStats.htmlParts[attribute] = allParts[attribute].parts;
        }
    }
    const ATTRIBUTE_INFO_LUT = {
        Power: [undefined, undefined, 66722, '', 1000, 1, Number.MAX_SAFE_INTEGER],
        Toughness: [undefined, 'Armor', 104162, '', 1000, 1, Number.MAX_SAFE_INTEGER],
        Vitality: [undefined, 'Health', 104163, '', 1000, 1, Number.MAX_SAFE_INTEGER],
        Precision: [undefined, 'CritChance', 156609, '', 1000, 1, Number.MAX_SAFE_INTEGER],
        Ferocity: [undefined, 'CritDamage', 156602, '', 0, 1, Number.MAX_SAFE_INTEGER],
        ConditionDamage: [undefined, undefined, 156600, '', 0, 1, Number.MAX_SAFE_INTEGER],
        Expertise: [undefined, 'ConditionDuration', 156601, '', 0, 1, Number.MAX_SAFE_INTEGER],
        Concentration: [undefined, 'BoonDuration', 156599, '', 0, 1, Number.MAX_SAFE_INTEGER],
        HealingPower: [undefined, undefined, 156606, '', 0, 1, Number.MAX_SAFE_INTEGER],
        AgonyResistance: [undefined, undefined, 536049, '', 0, 1, Number.MAX_SAFE_INTEGER],
        Health: ['Vitality', undefined, 536052, '', 0, 0.1, Number.MAX_SAFE_INTEGER],
        Armor: ['Toughness', undefined, 536048, '', 0, 1, Number.MAX_SAFE_INTEGER],
        ConditionDuration: ['Expertise', undefined, 156601, '%', 0, 1500, 2],
        BoonDuration: ['Concentration', undefined, 156599, '%', 0, 1500, 2],
        CritChance: ['Precision', undefined, 536051, '%', 0.05, 2100, Number.MAX_SAFE_INTEGER],
        CritDamage: ['Ferocity', undefined, 784327, '%', 1.5, 1500, Number.MAX_SAFE_INTEGER],
    };
    function getAttributeInformation(attribute, character) {
        const _p2 = ATTRIBUTE_INFO_LUT[attribute];
        let baseAttribute, computedAttribute, img, suffix = '', base = 0, div = 1, cap = Number.MAX_SAFE_INTEGER;
        if (_p2)
            [baseAttribute, computedAttribute, img, suffix, base, div, cap] = _p2;
        if (attribute == 'Health')
            base = getBaseHealth(character);
        return { baseAttribute, computedAttribute, img, suffix, base, div, cap };
    }
    function getBaseHealth(character) {
        return !character.profession
            ? 1000
            : {
                Guardian: 1645,
                Thief: 1645,
                Elementalist: 1645,
                Engineer: 5922,
                Ranger: 5922,
                Mesmer: 5922,
                Revenant: 5922,
                Necromancer: 9212,
                Warrior: 9212,
            }[character.profession];
    }
    function getAttributeValue(character, attribute) {
        return getActiveAttributes(character)[attribute];
    }
    function getActiveAttributes(character) {
        return character.statsWithWeapons[character.selectedWeaponSet].values;
    }
    function sumUpModifiers(character, attribute) {
        return [...(character.stats.sources[attribute] || []), ...(character.statsWithWeapons[character.selectedWeaponSet].sources[attribute] || [])];
    }
    const LUT_DEFENSE = [
        115, 120, 125, 129, 133, 137, 142, 146, 150, 154, 162, 168, 175, 182, 189, 196, 202, 209, 216, 223, 232, 240, 248, 257, 265, 274, 282, 290, 299, 307, 319, 330, 341, 352, 363, 374, 385, 396, 407, 418, 431, 443, 456, 469, 481, 494, 506, 519, 532, 544, 560, 575, 590, 606, 621, 636, 651, 666, 682, 697, 714, 731, 748, 764, 781, 798, 815, 832, 848, 865, 885, 905, 924, 943, 963, 982, 1002, 1021, 1040, 1060, 1081, 1102, 1123, 1144, 1165, 1186, 1207, 1228, 1249, 1270, 1291, 1312, 1333, 1354, 1375, 1396, 1417, 1438, 1459, 1480, 1501,
    ];
    const LUT_POWER_PLAYER = [
        170, 173, 176, 179, 182, 185, 188, 191, 194, 197, 202, 207, 212, 217, 222, 227, 232, 237, 242, 247, 253, 259, 265, 271, 277, 283, 289, 295, 301, 307, 315, 323, 331, 339, 347, 355, 363, 371, 379, 387, 396, 405, 414, 423, 432, 441, 450, 459, 468, 477, 488, 499, 510, 521, 532, 543, 554, 565, 576, 587, 599, 611, 623, 635, 647, 659, 671, 683, 695, 707, 721, 735, 749, 763, 777, 791, 805, 819, 833, 847, 862, 877, 892, 907, 922, 937, 952, 967, 982, 997, 1012, 1027, 1042, 1057, 1072, 1087, 1102, 1117, 1132, 1147, 1162,
    ];
    const LUT_POWER_MONSTER = [
        162, 179, 197, 214, 231, 249, 267, 286, 303, 322, 344, 367, 389, 394, 402, 412, 439, 454, 469, 483, 500, 517, 556, 575, 593, 612, 622, 632, 672, 684, 728, 744, 761, 778, 820, 839, 885, 905, 924, 943, 991, 1016, 1067, 1093, 1119, 1145, 1193, 1220, 1275, 1304, 1337, 1372, 1427, 1461, 1525, 1562, 1599, 1637, 1692, 1731, 1802, 1848, 1891, 1936, 1999, 2045, 2153, 2201, 2249, 2298, 2368, 2424, 2545, 2604, 2662, 2723, 2792, 2854, 2985, 3047, 3191, 3269, 3348, 3427, 3508, 3589, 3671, 3754, 3838, 3922, 4007, 4093, 4180, 4267, 4356, 4445, 4535, 4625, 4717, 4809, 4902,
    ];

    function calculateModifier({ formula, base_amount, formula_param1: level_scaling, formula_param2, source_attribute }, level, stats) {
        let { Power, ConditionDamage, HealingPower } = stats;
        if (source_attribute) {
            return stats[source_attribute] * base_amount / 100;
        }
        switch (formula) {
            case 'BuffLevelLinear':
                return level * level_scaling + base_amount;
            case 'ConditionDamage':
                return level * level_scaling + base_amount + ConditionDamage * formula_param2;
            case 'ConditionDamageSquared':
                return level * level * level_scaling + base_amount + ConditionDamage * formula_param2;
            case 'NoScaling':
                return base_amount;
            case 'Regeneration':
                return level * level_scaling + base_amount + HealingPower * formula_param2;
            case 'RegenerationSquared':
                return level * level * level_scaling + base_amount + HealingPower * formula_param2;
            case 'SpawnScaleLinear':
            case 'TargetLevelLinear':
                return level * level_scaling + base_amount;
            case 'BuffFormulaType11':
                return level * level_scaling + base_amount - formula_param2;
            case 'Power':
                return level * level_scaling + base_amount + Power * formula_param2;
            case 'PowerSquared':
                return level * level * level_scaling + base_amount + Power * formula_param2;
        }
        console.warn('[gw2-tooltips] [facts processor] Could not find formula #', formula, ', using base amount for now!');
        return base_amount;
    }
    function generateFacts(blocks, weaponStrength, context) {
        const [looseBlock, ...remainingBlocks] = blocks;
        let totalDefianceBreak = 0;
        const makeFactElements = (facts) => (!facts ? [] : facts
            .sort((a, b) => a.order - b.order)
            .map(fact => {
            const { wrapper, defiance_break } = generateFact(fact, weaponStrength, context);
            totalDefianceBreak += defiance_break;
            return wrapper;
        })
            .filter(d => d));
        const elements = [];
        for (const block of remainingBlocks) {
            const wrapper = newElm('div.fact-block');
            if (block.trait_requirements) {
                const trait_names = joinWordList(block.trait_requirements.map(id => { var _a; return `'<span class="gw2-color-traited-fact">${((_a = APICache.storage.traits.get(id)) === null || _a === void 0 ? void 0 : _a.name) || id}</span>'`; }));
                wrapper.append(fromHTML(`<span class="detail">Block exists because of trait${block.trait_requirements.length == 1 ? '' : 's'} ${trait_names}</span>`));
            }
            if (block.description)
                wrapper.append(newElm('p.description', fromHTML(GW2Text2HTML(block.description))));
            const blockFacts = makeFactElements(block.facts);
            wrapper.append(...blockFacts);
            elements.push(wrapper);
        }
        if (looseBlock)
            elements.push(...makeFactElements(looseBlock.facts));
        if (totalDefianceBreak > 0) {
            const defianceWrap = newElm('div.fact', newImg(ICONS.DEFIANCE_BREAK, 'iconmed'), newElm('div.gw2-color-defiance-fact', `Defiance Break: ${withUpToNDigits(totalDefianceBreak, 2)}`));
            elements.push(defianceWrap);
        }
        return elements;
    }
    function generateFact(fact, weapon_strength, context, itemMode = false) {
        let iconSlug = fact.icon;
        let buffStackSize = 1;
        let buffDuration = fact.duration;
        let defiance_break_per_s = fact.defiance_break;
        let activeStats = getActiveAttributes(context.character);
        const generateBuffDescription = (buff, fact, duration, valueMod) => {
            let modsArray = [];
            if (buff.modifiers && !buff.description_brief && !itemMode) {
                const relevantModifiers = buff.modifiers.filter(modifier => ((!modifier.source_trait_req || context.character.traits.includes(modifier.source_trait_req))
                    && (!modifier.mode || modifier.mode === context.gameMode)));
                let modsMap = new Map();
                for (let i = 0; i < relevantModifiers.length; i++) {
                    const modifier = relevantModifiers[i];
                    let entry = modsMap.get(modifier.id) || modsMap.set(modifier.id, { modifier: modifier, value: 0 }).get(modifier.id);
                    let value = calculateModifier(modifier, context.character.level, activeStats);
                    if (modifier.source_attribute) {
                        value *= activeStats[modifier.source_attribute];
                    }
                    entry.value += value;
                    if (modifier.flags.includes('SkipNextEntry')) {
                        i++;
                    }
                }
                for (let { value, modifier } of modsMap.values()) {
                    if (modifier.flags.includes('Subtract')) {
                        value -= 100;
                    }
                    if (modifier.flags.includes('MulByDuration')) {
                        let this_duration = duration / 1000;
                        if (modifier.flags.includes('DivDurationBy3')) {
                            this_duration /= 3;
                        }
                        if (modifier.flags.includes('DivDurationBy10')) {
                            this_duration /= 10;
                        }
                        value *= this_duration || 1;
                    }
                    if (!modifier.flags.includes('NonStacking')) {
                        value *= fact.apply_count;
                    }
                    if (modifier.formula.includes('Regeneration'))
                        value *= valueMod;
                    let strValue = modifier.flags.includes('FormatFraction')
                        ? drawFractional(value, exports.config)
                        : Math.floor(Math.fround(value)).toString();
                    if (modifier.flags.includes('FormatPercent')) {
                        if (value > 0) {
                            strValue = '+ ' + strValue;
                        }
                        strValue += '%';
                    }
                    strValue += ' ' + modifier.description;
                    if (typeof modifier.target_attribute_or_skill === 'string') {
                        const { computedAttribute } = getAttributeInformation(modifier.target_attribute_or_skill, context.character);
                        if (computedAttribute) {
                            const { div, suffix } = getAttributeInformation(computedAttribute, context.character);
                            const displayMul = suffix ? 100 : 1;
                            strValue += ` <span class="detail">(converts to ${n3(value / div * displayMul)}${suffix} ${mapLocale(computedAttribute)})</span>`;
                        }
                    }
                    modsArray.push(strValue);
                }
            }
            return GW2Text2HTML(buff.description_brief || modsArray.join(', ') || buff.description);
        };
        const applyMods = (baseDuration, buff, detailStack) => {
            let durMod = 1, valueMod = 1, cap = Number.MAX_SAFE_INTEGER;
            const durationAttr = (buff.buff_type == 'Boon' && 'BoonDuration') || (buff.buff_type == 'Condition' && 'ConditionDuration');
            if (durationAttr) {
                const { baseAttribute, div, cap: cap_ } = getAttributeInformation(durationAttr, context.character);
                cap = cap_;
                const attribVal = getAttributeValue(context.character, baseAttribute);
                durMod += attribVal / div;
                if (attribVal > 0 && exports.config.showFactComputationDetail) {
                    detailStack.push(`base duration: ${n3(baseDuration / 1000)}s`);
                    detailStack.push(`+ ${n3(baseDuration / 1000 * attribVal / div)}s (${n3(attribVal / div * 100)}%) from ${n3(attribVal)} ${baseAttribute}`);
                }
                for (const source of sumUpModifiers(context.character, durationAttr)) {
                    let mod = calculateModifier(source.modifier, context.character.level, activeStats) * source.count;
                    const innerSuffix = source.modifier.flags.includes('FormatPercent') ? '%' : '';
                    const displayMul = innerSuffix ? 100 : 1;
                    mod /= displayMul;
                    durMod += mod;
                    const toAdd = innerSuffix ? mod * baseDuration : mod;
                    if (exports.config.showFactComputationDetail) {
                        let text = `+ ${n3(toAdd / 1000)}s`;
                        if (innerSuffix)
                            text += ` (${n3(mod * displayMul)}%)`;
                        text += ' from ';
                        if (source.count > 1)
                            text += `${source.count} `;
                        text += source.source;
                        detailStack.push(newElm('div.detail', fromHTML(resolveInflections(text, source.count, context.character))));
                    }
                }
            }
            let durModStack = sumUpModifiers(context.character, buff.id);
            if (durModStack.length) {
                if (durMod === 1 && exports.config.showFactComputationDetail)
                    detailStack.push(`base duration: ${n3(baseDuration / 1000)}s`);
                let percentMod = 0;
                for (const { source, modifier, count } of durModStack) {
                    const mod = calculateModifier(modifier, context.character.level, activeStats);
                    if (exports.config.showFactComputationDetail)
                        detailStack.push(newElm('span.detail', `${n3ss(baseDuration / 1000 * mod / 100)}s (${n3(mod)}%) from ${count > 1 ? `${count} ` : ''}`, fromHTML(resolveInflections(source, count, context.character))));
                    percentMod += mod;
                }
                durMod += percentMod / 100;
            }
            const uncappedMod = durMod;
            durMod = Math.min(uncappedMod, cap);
            if (durMod != uncappedMod && exports.config.showFactComputationDetail) {
                detailStack.push(newElm('span.detail', `(Capped to ${n3(baseDuration / 1000 * cap)}s! Uncapped duration would be ${n3(baseDuration / 1000 * uncappedMod)}s)`));
            }
            baseDuration *= durMod;
            if (buff.name.includes('Regeneration')) {
                let valueModStack = context.character.stats.sources.HealEffectiveness;
                if (valueModStack.length) {
                    if (exports.config.showFactComputationDetail)
                        detailStack.push('regeneration value mods:');
                    let percentMod = 0;
                    for (const { source, modifier, count } of valueModStack) {
                        let mod = calculateModifier(modifier, context.character.level, activeStats);
                        if (modifier.source_attribute)
                            mod *= 100;
                        if (exports.config.showFactComputationDetail) {
                            const conversion = modifier.source_attribute
                                ? `${n3ss(mod)}% from ${n3(modifier.base_amount)} * ${n3(activeStats[modifier.source_attribute])} ${mapLocale(modifier.source_attribute)}`
                                : `${n3ss(mod)}%`;
                            detailStack.push(newElm('span.detail', `${conversion} from ${count > 1 ? `${count} ` : ''}`, fromHTML(resolveInflections(source, count, context.character))));
                        }
                        percentMod += mod;
                    }
                    valueMod += percentMod / 100;
                }
            }
            return [baseDuration, valueMod];
        };
        const factInflators = {
            AdjustByAttributeAndLevel: ({ fact }) => {
                var _a;
                let value = (fact.value + context.character.level ** fact.level_exponent * fact.level_multiplier) * fact.hit_count;
                let attributeVal = 0;
                if (fact.attribute) {
                    attributeVal = getAttributeValue(context.character, fact.attribute);
                    value += attributeVal * fact.attribute_multiplier * fact.hit_count;
                }
                const lines = [];
                if (exports.config.showFactComputationDetail) {
                    lines.push(`${n3(fact.value)} base value`);
                    if (fact.level_multiplier)
                        lines.push(`+ ${n3(context.character.level ** fact.level_exponent * fact.level_multiplier)} from lvl ${context.character.level} ^ ${n3(fact.level_exponent)} lvl exp. * ${n3(fact.level_multiplier)} lvl mul.`);
                    if (fact.attribute)
                        lines.push(`+ ${n3(attributeVal * fact.attribute_multiplier)} from ${n3(attributeVal)} ${mapLocale(fact.attribute)} * ${n3(fact.attribute_multiplier)} attrib. mod.`);
                    if (fact.hit_count != 1)
                        lines.push(` * ${fact.hit_count} hits`);
                }
                if ((_a = fact.text) === null || _a === void 0 ? void 0 : _a.includes('Heal')) {
                    let percentMod = 100;
                    for (const { source, modifier, count } of sumUpModifiers(context.character, 'HealEffectiveness')) {
                        let mod = calculateModifier(modifier, context.character.level, activeStats);
                        if (modifier.source_attribute)
                            mod *= 100;
                        if (exports.config.showFactComputationDetail) {
                            const conversion = modifier.source_attribute
                                ? `${n3(mod)}% from ${n3(modifier.base_amount)} * ${n3(activeStats[modifier.source_attribute])} ${mapLocale(modifier.source_attribute)}`
                                : `${n3(mod)}%`;
                            lines.push(newElm('span.detail', `${n3ss(mod / 100 * value)} (${conversion}) from ${count > 1 ? `${count} ` : ''}`, fromHTML(resolveInflections(source, count, context.character))));
                        }
                        percentMod += mod;
                    }
                    value *= percentMod / 100;
                }
                lines.unshift(`${GW2Text2HTML(fact.text) || mapLocale(fact.attribute)}: ${Math.round(value)}`);
                return lines;
            },
            AttributeAdjust: ({ fact }) => {
                const value = Math.round((fact.range[1] - fact.range[0]) / (context.character.level / 80) + fact.range[0]);
                const parts = [`${GW2Text2HTML(fact.text) || mapLocale(fact.target)}: ${n3s(value)}`];
                const { computedAttribute } = getAttributeInformation(fact.target, context.character);
                if (computedAttribute) {
                    const { div, suffix } = getAttributeInformation(computedAttribute, context.character);
                    const displayMul = suffix ? 100 : 1;
                    parts.push(`(converts to ${n3(value / div * displayMul)}${suffix} ${mapLocale(computedAttribute)})`);
                }
                return parts;
            },
            Buff: ({ fact, buff }) => {
                if (!buff)
                    console.error('[gw2-tooltips] [facts processor] buff #', fact.buff, ' is apparently missing in the cache');
                buff = buff || MISSING_BUFF;
                iconSlug = buff.icon || iconSlug;
                const parts = [];
                let valueMod;
                [buffDuration, valueMod] = applyMods(fact.duration, buff, parts);
                let buffDescription = generateBuffDescription(buff, fact, buffDuration, valueMod);
                if (buffDescription) {
                    if (itemMode)
                        buffDescription = `:<div style="margin-left: 0.5em;">${buffDescription}</div>`;
                    else
                        buffDescription = `: ${buffDescription}`;
                }
                const seconds = buffDuration > 0 ? ` (${formatDuration(buffDuration, exports.config)})` : '';
                parts.unshift(`${GW2Text2HTML(fact.text) || buff.name_brief || buff.name}${seconds}${buffDescription}`);
                buffStackSize = fact.apply_count;
                return parts;
            },
            BuffBrief: ({ fact, buff }) => {
                if (!buff)
                    console.error('[gw2-tooltips] [facts processor] buff #', fact.buff, ' is apparently missing in the cache');
                buff = buff || MISSING_BUFF;
                iconSlug = buff.icon || iconSlug;
                return [`${GW2Text2HTML(fact.text, buff.name)}`];
            },
            Distance: ({ fact }) => {
                return [`${GW2Text2HTML(fact.text)}: ${Math.round(fact.distance)}`];
            },
            Number: ({ fact: { text, value } }) => {
                const lines = [];
                if (defiance_break_per_s && text && text.includes('Defiance')) {
                    const modifiers = sumUpModifiers(context.character, 'Stun');
                    if (modifiers.length) {
                        if (exports.config.showFactComputationDetail)
                            lines.push(`${n3(value)} base value`);
                        let percentMod = 100;
                        for (const { source, modifier, count } of modifiers) {
                            const mod = calculateModifier(modifier, context.character.level, activeStats);
                            if (exports.config.showFactComputationDetail)
                                lines.push(newElm('span.detail', `${n3ss(mod)}% from ${count > 1 ? `${count} ` : ''}`, fromHTML(resolveInflections(source, count, context.character))));
                            percentMod += mod;
                        }
                        const mod = percentMod / 100;
                        value *= mod;
                        defiance_break_per_s *= mod;
                    }
                }
                lines.unshift(`${GW2Text2HTML(text)}: ${drawFractional(value, exports.config)}`);
                return lines;
            },
            Percent: ({ fact }) => {
                return [`${GW2Text2HTML(fact.text)}: ${drawFractional(fact.percent, exports.config)}%`];
            },
            PercentDamage: ({ fact }) => {
                return [`${GW2Text2HTML(fact.text)}: ${drawFractional(fact.percent, exports.config)}%`];
            },
            PercentLifeForceCost: ({ fact: { percent, text } }) => {
                const hpPool = getBaseHealth(context.character);
                const lines = [];
                lines.push(`${GW2Text2HTML(text)}: ${n3(Math.round(hpPool * percent * 0.01))}`);
                if (exports.config.showFactComputationDetail)
                    lines.push(`from ${n3(percent)}% * ${n3(hpPool)} HP base pool`);
                return lines;
            },
            PercentHealth: ({ fact: { percent, text } }) => {
                const raw = Math.round(getAttributeValue(context.character, 'Health') * percent * 0.01);
                return [`${GW2Text2HTML(text)}: ${drawFractional(percent, exports.config)}% (${raw} HP)`];
            },
            PercentLifeForceGain: ({ fact: { percent, text } }) => {
                const hpPool = getAttributeValue(context.character, 'Health');
                const lines = [];
                if (exports.config.showFactComputationDetail) {
                    lines.push(`${n3(percent * 0.01 * hpPool * 0.69)} from ${n3(percent)}% * (${n3(hpPool)} HP * 0.69) pool (${n3(getBaseHealth(context.character))} base pool modified by ${n3(getAttributeValue(context.character, 'Vitality'))} Vitality)`);
                }
                const modifiers = sumUpModifiers(context.character, 'LifeForce');
                if (modifiers.length) {
                    let percentMod = 100;
                    for (const { source, modifier, count } of modifiers) {
                        const mod = calculateModifier(modifier, context.character.level, activeStats);
                        if (exports.config.showFactComputationDetail)
                            lines.push(newElm('span.detail', `${n3ss(mod)}% from ${count > 1 ? `${count} ` : ''}`, fromHTML(resolveInflections(source, count, context.character))));
                        percentMod += mod;
                    }
                    percent *= percentMod / 100;
                }
                lines.unshift(`${GW2Text2HTML(text)}: ${drawFractional(percent, exports.config)}% (${Math.round(hpPool * 0.69 * percent * 0.01)})`);
                return lines;
            },
            Damage: ({ fact: { dmg_multiplier, hit_count, text }, weaponStrength }) => {
                const lines = [];
                const power = getAttributeValue(context.character, 'Power');
                let damage = dmg_multiplier * hit_count * weaponStrength * power / context.targetArmor;
                if (exports.config.showFactComputationDetail) {
                    lines.push(`${n3(damage)} from ${n3(dmg_multiplier)} internal mod. * ${n3(power)} power * ${weaponStrength} avg. weapon str. / ${context.targetArmor} target armor`);
                    if (hit_count != 1)
                        lines.push(`* ${hit_count} hits`);
                }
                const precision = getAttributeValue(context.character, 'Precision');
                const ferocity = getAttributeValue(context.character, 'Ferocity');
                const critChance = Math.min(0.05 + (precision - 1000) / 21 * 0.01, 1);
                const critDamage = 1.5 + ferocity / 15 * 0.01;
                const moreDmgFromCrit = damage * critChance * (critDamage - 1);
                damage += moreDmgFromCrit;
                if (exports.config.showFactComputationDetail) {
                    lines.push(`+ ${n3(moreDmgFromCrit)} (${n3(critChance * (critDamage - 1) * 100)}%) from ${n3(critChance * 100)}% crit chance and ${n3(critDamage * 100)}% damage on crit (${n3(precision)} precision and ${n3(ferocity)} ferocity)`);
                }
                const modifiers = sumUpModifiers(context.character, 'Damage');
                if (modifiers.length) {
                    let percentMod = 100;
                    for (const { source, modifier, count } of modifiers) {
                        const mod = calculateModifier(modifier, context.character.level, activeStats);
                        if (exports.config.showFactComputationDetail)
                            lines.push(newElm('span.detail', `${n3ss(mod)}% from ${count > 1 ? `${count} ` : ''}`, fromHTML(resolveInflections(source, count, context.character))));
                        percentMod += mod;
                    }
                    damage *= percentMod / 100;
                }
                const times = hit_count > 1 ? `(${hit_count}x)` : '';
                lines.unshift(`${GW2Text2HTML(text)}${times}: ${Math.round(damage)}`);
                return lines;
            },
            Time: ({ fact: { text } }) => {
                const lines = [];
                if (defiance_break_per_s && text && (text.includes('Stun') || text.includes('Daze')
                    || text.includes('Defiance'))) {
                    const modifiers = sumUpModifiers(context.character, 'Stun');
                    if (modifiers.length) {
                        if (exports.config.showFactComputationDetail)
                            lines.push(`${n3(buffDuration / 1000)}s base duration`);
                        let percentMod = 100;
                        for (const { source, modifier, count } of modifiers) {
                            const mod = calculateModifier(modifier, context.character.level, activeStats);
                            if (exports.config.showFactComputationDetail)
                                lines.push(newElm('span.detail', `${n3ss(mod)}% from ${count > 1 ? `${count} ` : ''}`, fromHTML(resolveInflections(source, count, context.character))));
                            percentMod += mod;
                        }
                        buffDuration *= percentMod / 100;
                    }
                }
                const time = buffDuration != 1000 ? 'seconds' : 'second';
                lines.unshift(`${GW2Text2HTML(text)}: ${drawFractional(buffDuration / 1000, exports.config)} ${time}`);
                return lines;
            },
            ComboField: ({ fact }) => {
                return [`${GW2Text2HTML(fact.text)}: ${mapLocale(fact.field_type)}`];
            },
            ComboFinisher: ({ fact }) => {
                return [`${GW2Text2HTML(fact.text)}: ${mapLocale(fact.finisher_type)}`];
            },
            AttributeConversion: ({ fact }) => {
                return [`Gain ${mapLocale(fact.target)} Based on a Percentage of ${mapLocale(fact.source)}: ${fact.percent}%`];
            },
            NoData: ({ fact }) => {
                return [GW2Text2HTML(fact.text)];
            },
            PrefixedBuff: ({ fact, buff }) => {
                let prefix = APICache.storage.skills.get(fact.prefix);
                if (!prefix)
                    console.error('[gw2-tooltips] [facts processor] prefix #', fact.prefix, ' is apparently missing in the cache');
                prefix = prefix || MISSING_BUFF;
                iconSlug = prefix.icon || iconSlug;
                if (!buff)
                    console.error('[gw2-tooltips] [facts processor] buff #', fact.buff, ' is apparently missing in the cache');
                buff = buff || MISSING_BUFF;
                let { duration, apply_count, text } = fact;
                const parts = [];
                let valueMod;
                [buffDuration, valueMod] = applyMods(duration, buff, parts);
                let buffDescription = generateBuffDescription(buff, fact, buffDuration, valueMod);
                if (buffDescription) {
                    buffDescription = `: ${buffDescription}`;
                }
                const seconds = buffDuration > 0 ? ` (${formatDuration(buffDuration, exports.config)})` : '';
                parts.unshift(newElm('div.fact', generateBuffIcon(buff.icon, apply_count), newElm('span', fromHTML(`${GW2Text2HTML(text) || buff.name_brief || buff.name}${seconds}${buffDescription}`))));
                return parts;
            },
            PrefixedBuffBrief: ({ fact, buff }) => {
                let prefix = APICache.storage.skills.get(fact.prefix);
                if (!prefix)
                    console.error('[gw2-tooltips] [facts processor] prefix #', fact.prefix, ' is apparently missing in the cache');
                prefix = prefix || MISSING_BUFF;
                iconSlug = prefix.icon || iconSlug;
                if (!buff)
                    console.error('[gw2-tooltips] [facts processor] buff #', fact.buff, ' is apparently missing in the cache');
                buff = buff || MISSING_BUFF;
                let node = newElm('div.fact', newImg(buff.icon), newElm('span', `${GW2Text2HTML(fact.text) || buff.name_brief || buff.name}`));
                return [node];
            },
            Range: ({ fact: { min, max } }) => {
                return [`Range: ${min ? `${min} - ${max}` : max}`];
            },
            StunBreak: () => {
                return ["Breaks Stun"];
            },
        };
        const buff = APICache.storage.skills.get(fact.buff || 0);
        const data = { fact, buff, weaponStrength: weapon_strength };
        const [firstLine, ...remainingDetail] = factInflators[fact.type](data);
        const wrapper = newElm('div.fact');
        if (fact.requires_trait) {
            wrapper.classList.add('gw2-color-traited-fact');
        }
        let defianceBreak = 0;
        if (defiance_break_per_s) {
            let effectiveBuffDuration = buffDuration || 1000;
            let breakDetail = '';
            if (buffDuration < 1000 && fact.text && (fact.text.includes('Stun') || fact.text.includes('Daze') || fact.text.includes('Float') || fact.text.includes('Knockdown'))) {
                effectiveBuffDuration = 1000;
                breakDetail = ' (hard CC -> min = 100)';
            }
            else if (effectiveBuffDuration != 1000) {
                breakDetail = ` (${fact.defiance_break}/s)`;
            }
            defianceBreak = defiance_break_per_s * effectiveBuffDuration / 1000;
            remainingDetail.push(newElm('span.detail.gw2-color-defiance-fact', `Defiance Break: ${withUpToNDigits(defianceBreak, 2)}${breakDetail}`));
        }
        if (fact.requires_trait) {
            const trait_names = joinWordList(fact.requires_trait.map(id => { var _a; return `'<span class="gw2-color-traited-fact">${((_a = APICache.storage.traits.get(id)) === null || _a === void 0 ? void 0 : _a.name) || id}</span>'`; }));
            remainingDetail.unshift(fromHTML(`<span class="detail">${(fact.skip_next && (fact.skip_next > 1 || !fact.__gamemode_override_marker)) ? 'overridden' : 'exists'} because of trait${fact.requires_trait.length == 1 ? '' : 's'} ${trait_names}</span>`));
        }
        wrapper.append(generateBuffIcon(iconSlug, buffStackSize));
        wrapper.append(newElm('div', newElm('span', typeof firstLine == 'string' && firstLine.includes('<') ? fromHTML(firstLine) : firstLine), ...remainingDetail.map(d => typeof d == 'string' ? newElm('span.detail', d) : d)));
        return { wrapper, defiance_break: defianceBreak };
    }
    function generateBuffIcon(icon, stackSize = 1) {
        const img = newImg(icon);
        if (stackSize == 1) {
            return img;
        }
        else {
            const wrap = newElm('span.buff-ico', img);
            wrap.setAttribute('count', String(stackSize));
            return wrap;
        }
    }
    const MISSING_BUFF = {
        id: 0,
        name: 'Missing Buff',
        description: '<c=@warning>This Buff failed to load</c>',
        categories: [], palettes: [], modifiers: [], flags: [],
    };
    const MISSING_SKILL = {
        id: 0,
        name: 'Missing Skill',
        description: '<c=@warning>This Skill failed to load</c>',
        categories: [], palettes: [], modifiers: [], flags: [],
    };

    function allUpgradeCounts(scope, mode = 3) {
        const elements = scope.getElementsByTagName('gw2object');
        for (const pair of contexts.entries()) {
            const elsInCorrectCtx = Array.from(elements).filter(e => (+String(e.getAttribute('contextSet')) || 0) == pair[0]);
            if (elsInCorrectCtx.length)
                _upgradeCounts(...pair, elsInCorrectCtx, mode);
        }
        const elsWithWrongCtx = Array.from(elements).filter(e => (+String(e.getAttribute('contextSet')) || 0) >= contexts.length);
        if (elsWithWrongCtx.length) {
            console.warn("[gw2-tooltips] [collect] Some targets in scope ", scope, " have the wrong context: ", elsWithWrongCtx);
        }
    }
    function _upgradeCounts(contextIndex, targetContext, elements, mode) {
        var _a, _b, _c, _d;
        const counts = {};
        for (const element of elements) {
            let id;
            if (element.getAttribute('type') !== 'item' || !(id = +String(element.getAttribute('objid'))))
                continue;
            const item = APICache.storage.items.get(id);
            if (!item || !('subtype' in item) || (!['Rune', 'Infusion'].includes(item.subtype)))
                continue;
            let amountToAdd = 1;
            if (item.subtype == "Infusion") {
                if (!(amountToAdd = +String(element.getAttribute('count')))) {
                    if (exports.config.legacyCompatibility) {
                        amountToAdd = _legacy_getInfusionCount(element);
                        if (!amountToAdd)
                            continue;
                    }
                }
                if (!amountToAdd) {
                    console.warn("[gw2-tooltips] [collect] Could not figure how many infusions to add for sourceElement ", element, ". Will not assume anything and just ignore the stack.");
                    continue;
                }
            }
            else if (targetContext.gameMode == "Pvp" && item.subtype == 'Rune') {
                amountToAdd = 6;
            }
            counts[item.id] = (counts[item.id] || 0) + amountToAdd;
        }
        switch (mode) {
            case 0:
                targetContext.character.upgradeCounts = counts;
                break;
            case 3:
                targetContext.character.upgradeCounts = Object.assign(targetContext.character.upgradeCounts, counts);
                break;
            case 1:
                {
                    if (window.GW2TooltipsContext instanceof Array) {
                        targetContext.character.upgradeCounts = Object.assign(counts, (_a = window.GW2TooltipsContext[contextIndex].character) === null || _a === void 0 ? void 0 : _a.upgradeCounts);
                    }
                    else if (window.GW2TooltipsContext) {
                        targetContext.character.upgradeCounts = Object.assign(counts, (_b = window.GW2TooltipsContext.character) === null || _b === void 0 ? void 0 : _b.upgradeCounts);
                    }
                    else {
                        targetContext.character.upgradeCounts = counts;
                    }
                }
                break;
            case 2:
                {
                    if (window.GW2TooltipsContext instanceof Array) {
                        targetContext.character.upgradeCounts = Object.assign({}, (_c = window.GW2TooltipsContext[contextIndex].character) === null || _c === void 0 ? void 0 : _c.upgradeCounts, counts);
                    }
                    else if (window.GW2TooltipsContext) {
                        targetContext.character.upgradeCounts = Object.assign({}, (_d = window.GW2TooltipsContext.character) === null || _d === void 0 ? void 0 : _d.upgradeCounts, counts);
                    }
                    else {
                        targetContext.character.upgradeCounts = counts;
                    }
                }
                break;
        }
    }
    function allStatSources(scope, mode = 3) {
        const elements = scope.getElementsByTagName('gw2object');
        for (const contextIndex of contexts.keys()) {
            const elsInCorrectCtx = Array.from(elements).filter(e => (+String(e.getAttribute('contextSet')) || 0) == contextIndex);
            if (elsInCorrectCtx.length)
                _statSources(contextIndex, contexts, elsInCorrectCtx, mode);
        }
        const elsWithWrongCtx = Array.from(elements).filter(e => (+String(e.getAttribute('contextSet')) || 0) >= contexts.length);
        if (elsWithWrongCtx.length) {
            console.warn("[gw2-tooltips] [collect] Some targets in scope ", scope, " have the wrong context: ", elsWithWrongCtx);
        }
    }
    function _statSources(contextIndex, contexts, elements, mode) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const context = contexts[contextIndex];
        const sources = structuredClone(DEFAULT_CONTEXT.character.stats.sources);
        const weaponSetSources = [];
        let upgrades = {};
        const actualInfusionCounts = contexts.map(ctx => {
            let total = 0;
            const counts = {};
            for (let [id, c] of Object.entries(ctx.character.upgradeCounts)) {
                let item;
                if ((item = APICache.storage.items.get(+id)) && 'subtype' in item && item.subtype == 'Infusion') {
                    c = Math.min(c, 18);
                    counts[id] = c;
                    total += c;
                }
            }
            let tooMany = Math.max(0, total - 18);
            for (let stop = 100; tooMany > 0 && stop > 0; stop--) {
                for (const [id, c] of Object.entries(counts).sort((a, b) => b[1] - a[1])) {
                    if (c > 2) {
                        const toRemove = (c & 1) ? 1 : 2;
                        counts[id] -= toRemove;
                        tooMany -= toRemove;
                        if (tooMany <= 0)
                            break;
                    }
                }
            }
            return counts;
        });
        for (const element of elements) {
            let id, type = element.getAttribute('type');
            if (!(id = +String(element.getAttribute('objid'))))
                continue;
            let amountToAdd = 1;
            let tiersToProcess, item, tierNumber, sourceRuneSuffix;
            if (type == 'item') {
                item = APICache.storage.items.get(id);
                if (!item || !('subtype' in item))
                    continue;
                if (item.type === 'UpgradeComponent' || item.type === 'Consumable') {
                    let tiersToAdd = 1;
                    if (item.subtype === 'Rune' && item.flags.includes('Pvp')) {
                        tiersToAdd = 6;
                    }
                    tierNumber = upgrades[item.id] = (upgrades[item.id] || 0) + tiersToAdd;
                    if (item.subtype === 'Rune') {
                        sourceRuneSuffix = true;
                        if (tierNumber > 6) {
                            if (!context.character.upgradeCounts[item.id])
                                console.warn("[gw2-tooltips] [collect] Found more than 6 runes of the same type. Here is the 7th rune element: ", element);
                            continue;
                        }
                        if (item.flags.includes('Pvp'))
                            tiersToProcess = item.tiers;
                        else
                            tiersToProcess = [item.tiers[tierNumber - 1]];
                    }
                    else if ('applies_buff' in item) {
                        const buff = APICache.storage.skills.get(item.applies_buff.buff);
                        if (!buff) {
                            console.warn(`[gw2-tooltips] [collect] Failed to resolve applied buff ${item.applies_buff} for `, element, ". Will not assume anything and just ignore the item.");
                            continue;
                        }
                        tiersToProcess = [{ modifiers: buff.modifiers }];
                    }
                    else if ('tiers' in item) {
                        if (item.subtype == 'Infusion' || item.subtype == 'Enrichment') {
                            if (!(amountToAdd = +String(element.getAttribute('count')))) {
                                if (exports.config.legacyCompatibility) {
                                    amountToAdd = _legacy_getInfusionCount(element);
                                    if (!amountToAdd)
                                        continue;
                                }
                            }
                            if (!amountToAdd) {
                                console.warn("[gw2-tooltips] [collect] Could not figure how many infusions to add for sourceElement ", element, ". Will not assume anything and just ignore the stack.");
                                continue;
                            }
                        }
                        else if (item.subtype === 'Sigil' && tierNumber > 1) {
                            if (tierNumber > 2)
                                console.warn("[gw2-tooltips] [collect] Found more than 2 sigils of the same type. Here is the 3th sigil element: ", element);
                            continue;
                        }
                        tiersToProcess = item.tiers;
                    }
                }
            }
            else if (type == 'pvp/amulet') {
                item = APICache.storage['pvp/amulets'].get(id);
                if (!item)
                    continue;
            }
            let attributeSet = item && findCorrectAttributeSet(item, +String(element.getAttribute('stats')) || undefined);
            if (attributeSet) {
                tiersToProcess = [{
                        modifiers: attributeSet.attributes.map(a => ({
                            target_attribute_or_skill: a.attribute,
                            base_amount: Math.round(a.base_value + item.attribute_base * a.scaling),
                            formula: "NoScaling",
                            flags: [], id: -1, formula_param1: 0, formula_param2: 0, description: '',
                        }))
                    }];
            }
            if (item && 'defense' in item) {
                const defense = (typeof item.defense == "number")
                    ? item.defense
                    : LUT_DEFENSE[Math.min(100, (item.defense[0] + context.character.level))] * item.defense[1];
                if (!tiersToProcess)
                    tiersToProcess = [{ modifiers: [] }];
                tiersToProcess[0].modifiers.push({
                    target_attribute_or_skill: 'Armor',
                    base_amount: Math.ceil(defense),
                    formula: "NoScaling",
                    flags: [], id: -1, formula_param1: 0, formula_param2: 0, description: '',
                });
            }
            let targetSources = sources;
            const weaponSetId = +String(element.getAttribute('weaponSet'));
            if (isNaN(weaponSetId) && item && item.type == "UpgradeComponent") {
                const override = actualInfusionCounts[contextIndex][item.id];
                if (override) {
                    amountToAdd = override;
                }
                else if (amountToAdd > 18) {
                    amountToAdd = 18;
                }
            }
            if (!isNaN(weaponSetId)) {
                targetSources = weaponSetSources[weaponSetId] || (weaponSetSources[weaponSetId] = structuredClone(DEFAULT_CONTEXT.character.stats.sources));
            }
            if (tiersToProcess)
                for (const [i, tier] of tiersToProcess.entries()) {
                    if (tier.modifiers)
                        for (const mod of tier.modifiers) {
                            if (!mod.target_attribute_or_skill || (mod.mode && mod.mode !== context.gameMode) || (mod.source_trait_req && !context.character.traits.includes(mod.source_trait_req)) || (mod.target_trait_req && !context.character.traits.includes(mod.target_trait_req)))
                                continue;
                            let source = formatItemName(item, context, attributeSet, undefined, -1);
                            if (sourceRuneSuffix) {
                                source = `${source} (Tier ${tiersToProcess.length === 1 ? tierNumber : i + 1} Bonus)`;
                            }
                            (targetSources[mod.target_attribute_or_skill] || (targetSources[mod.target_attribute_or_skill] = []))
                                .push({ modifier: mod, source, count: amountToAdd });
                        }
                }
        }
        const character = context.character;
        const overwriteWeaponStatSources = () => {
            for (const [i, sources] of weaponSetSources.entries()) {
                const target = character.statsWithWeapons[i];
                if (target)
                    target.sources = sources;
                else
                    character.statsWithWeapons[i] = {
                        sources,
                        values: Object.assign({}, DEFAULT_CONTEXT.character.statsWithWeapons[0].values),
                        htmlParts: structuredClone(DEFAULT_CONTEXT.character.statsWithWeapons[0].htmlParts),
                    };
            }
        };
        switch (mode) {
            case 0:
                character.stats.sources = sources;
                overwriteWeaponStatSources();
                break;
            case 3:
                {
                    for (const [k, values] of Object.entries(sources)) {
                        (character.stats.sources[k] || (character.stats.sources[k] = []))
                            .push(...values);
                    }
                    for (const [i, sources] of weaponSetSources.entries()) {
                        const target = character.statsWithWeapons[i];
                        if (target) {
                            for (const [k, values] of Object.entries(sources)) {
                                (target.sources[k] || (target.sources[k] = []))
                                    .push(...values);
                            }
                        }
                        else
                            character.statsWithWeapons[i] = {
                                sources,
                                values: Object.assign({}, DEFAULT_CONTEXT.character.statsWithWeapons[0].values),
                                htmlParts: structuredClone(DEFAULT_CONTEXT.character.statsWithWeapons[0].htmlParts),
                            };
                    }
                }
                break;
            case 1:
                {
                    if (window.GW2TooltipsContext instanceof Array) {
                        character.stats.sources = Object.assign(sources, (_b = (_a = window.GW2TooltipsContext[contextIndex].character) === null || _a === void 0 ? void 0 : _a.stats) === null || _b === void 0 ? void 0 : _b.sources);
                        console.assert(false );
                    }
                    else if (window.GW2TooltipsContext) {
                        character.stats.sources = Object.assign(sources, (_d = (_c = window.GW2TooltipsContext.character) === null || _c === void 0 ? void 0 : _c.stats) === null || _d === void 0 ? void 0 : _d.sources);
                        console.assert(false );
                    }
                    else {
                        character.stats.sources = sources;
                        overwriteWeaponStatSources();
                    }
                }
                break;
            case 2:
                {
                    if (window.GW2TooltipsContext instanceof Array) {
                        character.stats.sources = Object.assign({}, (_f = (_e = window.GW2TooltipsContext[contextIndex].character) === null || _e === void 0 ? void 0 : _e.stats) === null || _f === void 0 ? void 0 : _f.sources, sources);
                        console.assert(false );
                    }
                    else if (window.GW2TooltipsContext) {
                        character.stats.sources = Object.assign({}, (_h = (_g = window.GW2TooltipsContext.character) === null || _g === void 0 ? void 0 : _g.stats) === null || _h === void 0 ? void 0 : _h.sources, sources);
                        console.assert(false );
                    }
                    else {
                        character.stats.sources = sources;
                        overwriteWeaponStatSources();
                    }
                }
                break;
        }
    }
    function _legacy_getInfusionCount(element) {
        var _a, _b;
        const ownIndex = Array.prototype.indexOf.call(element.parentElement.children, element);
        const amountEl = element.parentElement.getElementsByClassName('amount')[ownIndex];
        if (!amountEl) {
            console.warn("[gw2-tooltips] [collect] `legacyCompatibility` is active, but no amount element for infusion ", element, " could be found. Will not assume anything and just ignore the stack.");
            return;
        }
        const amountToAdd = +String((_b = (_a = amountEl.textContent) === null || _a === void 0 ? void 0 : _a.match(/\d+/)) === null || _b === void 0 ? void 0 : _b[0]);
        if (!amountToAdd) {
            console.warn("[gw2-tooltips] [collect] [legacyCompatibility] Amount element ", amountEl, " for infusion element ", element, " did not contain any readable amount. Will not assume anything and just ignore the stack.");
            return;
        }
        if (amountToAdd < 1 || amountToAdd > 20) {
            console.warn("[gw2-tooltips] [collect] [legacyCompatibility] Amount element ", amountEl, " for infusion element ", element, " did got interpreted as x", amountToAdd, " which is outside of the range of sensible values (amount in [1...20]). Will not assume anything and just ignore the stack.");
            return;
        }
        return amountToAdd;
    }
    function allTraits(scope, mode = 3) {
        const elements = scope.querySelectorAll('gw2object[type=specialization]:not(.gw2objectembed)');
        for (const pair of contexts.entries()) {
            const elsInCorrectCtx = Array.from(elements).filter(e => (+String(e.getAttribute('contextSet')) || 0) == pair[0]);
            if (elsInCorrectCtx.length)
                _traits(...pair, elsInCorrectCtx, mode);
        }
        const elsWithWrongCtx = Array.from(elements).filter(e => (+String(e.getAttribute('contextSet')) || 0) >= contexts.length);
        if (elsWithWrongCtx.length) {
            console.warn("[gw2-tooltips] [collect] Some targets in scope ", scope, " have the wrong context: ", elsWithWrongCtx);
        }
    }
    function _traits(contextIndex, targetContext, elements, mode) {
        var _a, _b, _c, _d;
        const traits = [];
        const specializations = [];
        for (const specialization of elements) {
            const specId = +String(specialization.getAttribute('objid'));
            if (!isNaN(specId)) {
                specializations.push(specId);
            }
            const selectedPositions = String(specialization.getAttribute('selected_traits')).split(',').map(i => +i).filter(i => !isNaN(i) && 0 <= i && i <= 2);
            if (selectedPositions.length != 3) {
                console.warn("[gw2-tooltips] [collect] Specialization object ", specialization, " does not have its 'selected_traits' (properly) set. Add the attribute as `selected_traits=\"0,2,1\"` where the numbers are 0-2 indicating top, middle or bottom selection. Will not assume anything and just ignore the element.");
                continue;
            }
            for (const [x, y] of selectedPositions.entries()) {
                {
                    const traitEl = specialization.children[1 + x * 2].children[y];
                    let id;
                    if (!traitEl || !(id = +String(traitEl.getAttribute('objid')))) {
                        console.warn("[gw2-tooltips] [collect] Trait object ", traitEl, " is selected but does not exist or does not have an objid set. Add the attribute as `objid=\"1234\"`. Will not assume anything and just ignore the element.");
                        continue;
                    }
                    traits.push(id);
                }
                {
                    const traitEl = specialization.children[x * 2];
                    let id;
                    if (!(id = +String(traitEl.getAttribute('objid')))) {
                        console.warn("[gw2-tooltips] [collect] Minor trait object ", traitEl, " does not have an objid set. Add the attribute as `objid=\"1234\"`. Will not assume anything and just ignore the element.");
                        continue;
                    }
                    traits.push(id);
                }
            }
        }
        switch (mode) {
            case 0:
            case 2:
                targetContext.character.traits = traits;
                targetContext.character.specializations = specializations;
                break;
            case 3:
            case 1:
                {
                    if (window.GW2TooltipsContext instanceof Array) {
                        const set = new Set((_a = window.GW2TooltipsContext[contextIndex].character) === null || _a === void 0 ? void 0 : _a.traits);
                        traits.forEach(t => set.add(t));
                        targetContext.character.traits = Array.from(set);
                        const set2 = new Set((_b = window.GW2TooltipsContext[contextIndex].character) === null || _b === void 0 ? void 0 : _b.specializations);
                        specializations.forEach(t => set2.add(t));
                        targetContext.character.specializations = Array.from(set2);
                    }
                    else if (window.GW2TooltipsContext) {
                        const set = new Set((_c = window.GW2TooltipsContext.character) === null || _c === void 0 ? void 0 : _c.traits);
                        traits.forEach(t => set.add(t));
                        targetContext.character.traits = Array.from(set);
                        const set2 = new Set((_d = window.GW2TooltipsContext.character) === null || _d === void 0 ? void 0 : _d.specializations);
                        specializations.forEach(t => set2.add(t));
                        targetContext.character.specializations = Array.from(set2);
                    }
                    else {
                        targetContext.character.traits = traits;
                        targetContext.character.specializations = specializations;
                    }
                }
                break;
        }
    }
    function traitEffects(contexts) {
        for (const context of contexts) {
            for (const traitId of context.character.traits) {
                const trait = APICache.storage.traits.get(traitId);
                if (!trait) {
                    console.error(`[gw2-tooltips] [collect] Trait #${traitId} is apparently missing in the cache.`);
                    continue;
                }
                const addModifiers = (modifiers) => {
                    for (const mod of modifiers) {
                        if (!mod.target_attribute_or_skill || (mod.mode && mod.mode !== context.gameMode) || (mod.source_trait_req && !context.character.traits.includes(mod.source_trait_req)) || (mod.target_trait_req && !context.character.traits.includes(mod.target_trait_req)))
                            continue;
                        (context.character.stats.sources[mod.target_attribute_or_skill] || (context.character.stats.sources[mod.target_attribute_or_skill] = []))
                            .push({ source: `trait '<span class="gw2-color-traited-fact">${trait.name}</span>'`, modifier: mod, count: 1 });
                    }
                };
                if (trait.modifiers)
                    addModifiers(trait.modifiers);
                const contextBoundInfo = resolveTraitsAndOverrides(trait, context);
                if (contextBoundInfo.blocks)
                    for (const block of contextBoundInfo.blocks)
                        if (block.facts)
                            for (const fact of block.facts) {
                                if (!('buff' in fact))
                                    continue;
                                const buff = APICache.storage.skills.get(fact.buff);
                                if (!buff) {
                                    console.error(`[gw2-tooltips] [collect] Buff #${fact.buff} required for trait effect collection is apparently missing in the cache.`);
                                    continue;
                                }
                                if (buff.modifiers && !['Boon', 'Condition'].includes(buff.buff_type)) {
                                    console.info(`[gw2-tooltips] [collect] [trait-effects] ${trait.name} applies ${buff.buff_type} ${buff.name}: ${buff.modifiers.length} mods`);
                                    addModifiers(buff.modifiers);
                                }
                            }
            }
        }
    }

    function inflateGenericIcon(gw2Object, data, force = false) {
        if (!force && gw2Object.childElementCount > 0)
            return;
        const wikiLink = newElm('a', newImg(data.icon, undefined, data.name));
        wikiLink.href = 'https://wiki-en.guildwars2.com/wiki/Special:Search/' + resolveInflections(GW2Text2HTML(data.name), 1, { sex: "Male" });
        wikiLink.target = '_blank';
        if (gw2Object.classList.contains('gw2objectembed') && !gw2Object.classList.contains('icononly')) {
            const cleanName = GW2Text2HTML(data.name).replaceAll(/\[.*?\]/g, '');
            wikiLink.append(cleanName);
        }
        gw2Object[force ? 'replaceChildren' : 'append'](wikiLink);
    }
    function inflateSkill(gw2Object, skill) {
        const contextSet = +String(gw2Object.getAttribute('contextSet')) || 0;
        const context = specializeContextFromInlineAttribs(contexts[contextSet], gw2Object);
        let force = false;
        if (gw2Object.classList.contains('auto-transform')) {
            const replacementSkill = findTraitedOverride(skill, context);
            if (replacementSkill) {
                gw2Object.setAttribute('objid', String(replacementSkill.id));
                skill = replacementSkill;
                force = true;
            }
        }
        inflateGenericIcon(gw2Object, skill, force);
    }
    function inflateItem(gw2Object, item) {
        if (gw2Object.childElementCount > 0)
            return;
        const stackSize = +String(gw2Object.getAttribute('count')) || 1;
        const context = contexts[+String(gw2Object.getAttribute('contextSet')) || 0];
        const wikiLink = newElm('a', newImg(item.icon, undefined, item.name));
        wikiLink.href = 'https://wiki-en.guildwars2.com/wiki/Special:Search/' + GW2Text2HTML(item.name).replaceAll(/\[.*?\]/g, '');
        wikiLink.target = '_blank';
        if (gw2Object.classList.contains('gw2objectembed'))
            wikiLink.append(formatItemName(item, context, undefined, undefined, stackSize));
        gw2Object.append(wikiLink);
    }
    function inflateSpecialization(gw2Object, spec) {
        if (gw2Object.classList.contains('gw2objectembed')) {
            inflateGenericIcon(gw2Object, spec);
        }
        else {
            gw2Object.style.backgroundImage = `url(${spec.background.includes(':') ? spec.background : IMAGE_CDN + spec.background})`;
            gw2Object.dataset.label = spec.name;
            const selectedPositions = String(gw2Object.getAttribute('selected_traits')).split(',').map(i => +i).filter(i => !isNaN(i) && 0 <= i && i <= 2);
            if (selectedPositions.length != 3) {
                console.warn("[gw2-tooltips] [inflator] Specialization object ", gw2Object, " does not have its 'selected_traits' (properly) set. Add the attribute as `selected_traits=\"0,2,1\"` where the numbers are 0-2 indicating top, middle or bottom selection.");
                return;
            }
            for (const [x, y] of selectedPositions.entries()) {
                const column = gw2Object.children[1 + x * 2];
                if (!column) {
                    console.warn("[gw2-tooltips] [inflator] Cannot mark selected trait object in column #", x, " for specialization object ", gw2Object, " because the column doesn't seem to exist. Either mark the specialization object as inline or add the missing column.");
                    continue;
                }
                for (const [i, traitEl] of Array.prototype.entries.call(column.children)) {
                    traitEl.classList.toggle('trait_unselected', i !== y);
                }
            }
        }
    }
    function inflateAttribute(gw2Object, attribute) {
        const context = contexts[+String(gw2Object.getAttribute('contextSet')) || 0];
        const value = getAttributeValue(context.character, attribute);
        const _p = {
            Power: [66722, ''],
            Toughness: [104162, ''],
            Vitality: [104163, ''],
            Precision: [156609, ''],
            Ferocity: [156602, ''],
            ConditionDamage: [156600, ''],
            Expertise: [156601, ''],
            Concentration: [156599, ''],
            HealingPower: [156606, ''],
            AgonyResistance: [536049, ''],
            Health: [536052, ''],
            Armor: [536048, ''],
            ConditionDuration: [156601, '%'],
            BoonDuration: [156599, '%'],
            CritChance: [536051, '%'],
            CritDamage: [784327, '%'],
            MagicFind: [536054, '%'],
        }[attribute];
        let img, suffix = '';
        if (_p)
            [img, suffix] = _p;
        else {
            console.warn(`[gw2-tooltips] [inflator] Unknown attribute '${attribute}' on object `, gw2Object);
        }
        const displayMul = suffix ? 100 : 1;
        let search = mapLocale(attribute);
        if (attribute == 'Profession') {
            search = "Attribute#Profession_Attributes";
        }
        const wikiLink = newElm('a', newImg(img));
        wikiLink.href = `https://wiki-en.guildwars2.com/wiki/Special:Search/${search}`;
        wikiLink.target = '_blank';
        if (gw2Object.classList.contains('gw2objectembed')) {
            if (value !== undefined) {
                wikiLink.append(withUpToNDigits(value * displayMul, 1) + suffix);
            }
            else {
                wikiLink.append('???' + suffix);
            }
        }
        gw2Object.replaceChildren(wikiLink);
    }
    function _legacy_transformEffectToSkillObject(gw2Object, error_store) {
        const name = String(gw2Object.getAttribute('objId'));
        let id = {
            chaos_aura: 10332,
            dark_aura: 39978,
            fire_aura: 5677,
            frost_aura: 5579,
            light_aura: 25518,
            magnetic_aura: 5684,
            shocking_aura: 5577,
            aegis: 743,
            alacrity: 30328,
            fury: 725,
            might: 740,
            protection: 717,
            quickness: 1187,
            regeneration: 718,
            resistance: 26980,
            resolution: 873,
            stability: 1122,
            swiftness: 719,
            vigor: 726,
            bleeding: 736,
            blinded: 720,
            burning: 737,
            chill: 722,
            chilled: 722,
            confusion: 861,
            crippled: 721,
            fear: 896,
            immobilize: 727,
            poison: 723,
            slow: 26766,
            taunt: 27705,
            torment: 19426,
            vulnerability: 738,
            weakness: 742,
            daze: 833,
            stun: 872,
            agony: 15773,
            invulnerability: 56227,
            revealed: 890,
            stealth: 58026,
            superspeed: 5974,
            unblockable: 18843,
            blight: 62653,
            bloodstone_blessed: 34917,
            blue_pylon_power: 31413,
            champion_of_the_legions: 20845,
            compromised: 35096,
            crowd_favor: 36173,
            curse_of_frailty: 53723,
            debilitated: 67972,
            debilitating_void: 64967,
            defense_up: 28482,
            derangement: 34965,
            elemental_empowerment: 62733,
            empowering_auras: 62939,
            equalization_matrix: 67047,
            expose_weakness: 26660,
            exposed: 28778,
            extreme_vulnerability: 65662,
            fixated: 47434,
            growing_rage_ashym: 3362,
            ignite: 16259,
            intervention: 35061,
            necrosis: 47414,
            not_sticking_together: 54378,
            nova: 39193,
            ooze_pheromone: 21538,
            photon_saturation: 67872,
            positive_flow: 66665,
            power_of_the_void: 65601,
            reinforced_armor: 9283,
            relentless_fire: 62805,
            retaliation_ashym: 24646,
            sentinel_retribution: 16350,
            shattering_ice: 62909,
            shell_shocked: 33361,
            spectral_darkness: 31498,
            sticking_together: 54604,
            synchronized_vitality: 63840,
            unnatural_signet: 38224,
            use_soul_binder: 55630,
            void_empowerment: 68083,
            xeras_embrace: 34979,
        }[name];
        if (!id) {
            const hardCoded = {
                barrier: {
                    id: 1,
                    name: 'Barrier',
                    icon: ICONS.BARRIER,
                    description: "Creates a health barrier that takes damage prior to the health bar. Barrier disappears 5s after being applied. Applying a barrier while one is already active will add to it, but the previously-existing barrier will still disappear 5s after it was originally applied. The amount of barrier generated is based on the source's healing power, and is capped at 50% of the recipient's maximum health.",
                    description_brief: "Creates a health barrier that takes damage prior to the health bar.",
                    categories: [], palettes: [], flags: [],
                },
                stunbreak: {
                    id: 2,
                    name: 'Stun Break',
                    description: 'Cancel control effects such as stuns.',
                    icon: ICONS.STUN_BREAK,
                    categories: [], palettes: [], flags: [],
                },
                knockdown: {
                    id: 3,
                    name: 'Knockdown',
                    description: 'Knocks the target on ground, preventing movement and actions for a short duration.',
                    icon: ICONS.KNOCKDOWN,
                    categories: [], palettes: [], flags: [],
                },
                pull: {
                    id: 4,
                    name: 'Pull',
                    description: 'Pulls the caster to the target or the target to a specific location and disables them for a short duration.',
                    icon: ICONS.PULL,
                    categories: [], palettes: [], flags: [],
                },
                knockback: {
                    id: 5,
                    name: 'Knockback',
                    description: 'Knocks back the target away and on the ground, preventing movement and actions for a short duration.',
                    icon: ICONS.KNOCKBACK,
                    categories: [], palettes: [], flags: [],
                },
                launch: {
                    id: 6,
                    name: 'Launch',
                    description: 'Throws the target in the air over a short distance, preventing movement and actions for a short duration. Can move Downed targets.',
                    icon: ICONS.LAUNCH,
                    categories: [], palettes: [], flags: [],
                },
                float: {
                    id: 7,
                    name: 'Float',
                    description: 'Causes the target to float in the air, preventing movement and actions for a short duration. Causes underwater targets to move up.',
                    icon: ICONS.FLOAT,
                    categories: [], palettes: [], flags: [],
                },
                sink: {
                    id: 8,
                    name: 'Sink',
                    description: 'Causes the underwater target to move downwards.',
                    icon: ICONS.SINK,
                    categories: [], palettes: [], flags: [],
                },
            }[name];
            if (hardCoded) {
                id = hardCoded.id;
                APICache.storage.skills.set(id, hardCoded);
            }
        }
        if (id) {
            gw2Object.setAttribute('type', 'skill');
            gw2Object.setAttribute('objId', String(id));
            return id;
        }
        else {
            gw2Object.innerText = name;
            gw2Object.title = `Failed to translate effect '${name}'.`;
            gw2Object.style.cursor = "help";
            gw2Object.classList.add('error');
            error_store.add(name);
            return 0;
        }
    }
    function inferItemUpgrades(wrappers) {
        const remainingInfusionsByContext = contexts.map(ctx => {
            const counts = {};
            for (const [id, c] of Object.entries(ctx.character.upgradeCounts)) {
                let item;
                if ((item = APICache.storage.items.get(+id)) && 'subtype' in item && item.subtype == 'Infusion')
                    counts[+id] = c;
            }
            return counts;
        });
        const enrichmentByContext = contexts.map(ctx => {
            for (const [id, c] of Object.entries(ctx.character.upgradeCounts)) {
                let item;
                if ((item = APICache.storage.items.get(+id)) && 'subtype' in item && item.subtype == 'Enrichment')
                    return id;
            }
        });
        for (const wrapper of wrappers) {
            if (wrapper.childElementCount < 2)
                continue;
            const [itemEl, ...upgradeEls] = wrapper.children;
            if (itemEl.getAttribute('type') !== 'item')
                continue;
            const itemCtx = +String(itemEl.getAttribute('contextSet')) || 0;
            const upgradeIds = upgradeEls.filter(u => u.getAttribute('type') === 'item' && u.getAttribute('objid')
                && (+String(itemEl.getAttribute('contextSet')) || 0) === itemCtx)
                .map(u => u.getAttribute('objid'));
            {
                let id, item;
                if ((id = +String(itemEl.getAttribute('objid'))) && (item = APICache.storage.items.get(id)) && 'slots' in item) {
                    for (const slot of item.slots) {
                        if (slot == 'Infusion') {
                            const remainingInfusions = remainingInfusionsByContext[itemCtx];
                            for (const infusionId of Object.keys(remainingInfusions)) {
                                upgradeIds.push(infusionId);
                                if (--remainingInfusions[infusionId] < 1) {
                                    delete remainingInfusions[infusionId];
                                }
                                break;
                            }
                        }
                        else if (slot == 'Enrichment') {
                            const enrichment = enrichmentByContext[itemCtx];
                            if (enrichment)
                                upgradeIds.push(enrichment);
                        }
                    }
                }
            }
            const attrString = upgradeIds.join(',');
            if (attrString)
                itemEl.setAttribute('slotted', attrString);
        }
    }

    let tooltip;
    let lastTooltipTarget;
    let cyclePos = 0;
    let lastMouseX;
    let lastMouseY;
    const contexts = [];
    exports.config = null;
    function _constructor() {
        if (window.GW2TooltipsContext instanceof Array) {
            for (const partialContext of window.GW2TooltipsContext)
                contexts.push(createCompleteContext(partialContext));
        }
        else if (window.GW2TooltipsContext) {
            contexts.push(createCompleteContext(window.GW2TooltipsContext));
        }
        else {
            contexts.push(createCompleteContext({}));
        }
        exports.config = Object.assign({}, DEFAULT_CONFIG, window.GW2TooltipsConfig);
        if (exports.config.apiImpl)
            APICache.apiImpl = exports.config.apiImpl(APIs);
        tooltip = newElm('div.tooltipWrapper');
        tooltip.style.display = 'none';
        if (document.body)
            document.body.appendChild(tooltip);
        else
            document.addEventListener('DOMContentLoaded', () => document.body.appendChild(tooltip));
        const isMobile = /android|webos|iphone|ipad|ipod|blackberry|bb|playbook|mobile|windows phone|kindle|silk|opera mini/.test(navigator.userAgent.toLowerCase());
        document.addEventListener('mousemove', event => {
            if (isMobile && (Math.abs(event.pageX - lastMouseX) + Math.abs(event.pageY - lastMouseY) > 20)) {
                tooltip.style.display = 'none';
            }
            lastMouseX = event.pageX;
            lastMouseY = event.pageY;
            if (tooltip.style.display != 'none')
                positionTooltip();
        });
        document.addEventListener('contextmenu', event => {
            const node = findSelfOrParent(event.target, 'gw2object');
            if (!node)
                return;
            if (node.classList.contains('cycler') && tooltip.style.display != 'none') {
                event.preventDefault();
                do {
                    cyclePos = (cyclePos + 1) % tooltip.childElementCount;
                } while (tooltip.children[cyclePos].classList.contains('not-collapsable'));
                activateSubTooltip(cyclePos);
                scrollSubTooltipIntoView(cyclePos, true);
                positionTooltip(true);
            }
            if (isMobile && tooltip.style.display == 'none') {
                event.preventDefault();
                showTooltipFor(node);
                positionTooltip();
            }
        });
        let touch;
        const scrollHandler = (event) => {
            if (tooltip.style.display == 'none')
                return;
            const activeTT = tooltip.children[cyclePos];
            if (activeTT.scrollHeight == activeTT.clientHeight)
                return;
            event.preventDefault();
            const deltaY = event.deltaY || event.detail || event.touches[0].clientY - touch.clientY;
            activeTT.scrollBy(0, deltaY);
        };
        const passive = 'onwheel' in window ? { passive: false } : false;
        window.addEventListener('DOMMouseScroll', scrollHandler, false);
        window.addEventListener('wheel', scrollHandler, passive);
        window.addEventListener('touchstart', event => {
            touch = event.touches[0];
        });
        window.addEventListener('touchmove', scrollHandler, passive);
        window.addEventListener('keydown', e => {
            if (e.ctrlKey && e.altKey) {
                if (e.key == 'd') {
                    e.preventDefault();
                    exports.config.showFactComputationDetail = !exports.config.showFactComputationDetail;
                    console.log(`[gw2-tooltips] [cfg] showFactComputationDetail is now ${exports.config.showFactComputationDetail}`);
                    if (lastTooltipTarget && tooltip.style.display != 'none') {
                        showTooltipFor(lastTooltipTarget, cyclePos);
                        positionTooltip();
                    }
                }
                else if (e.key == 't') {
                    e.preventDefault();
                    exports.config.showPreciseAbilityTimings = !exports.config.showPreciseAbilityTimings;
                    console.log(`[gw2-tooltips] [cfg] showPreciseAbilityTimings is now ${exports.config.showPreciseAbilityTimings}`);
                    if (lastTooltipTarget && tooltip.style.display != 'none') {
                        showTooltipFor(lastTooltipTarget, cyclePos);
                        positionTooltip();
                    }
                }
            }
        });
    }
    function activateSubTooltip(tooltipIndex) {
        const tooltips = tooltip.children;
        for (let index = 0; index < tooltips.length; index++) {
            if (!tooltips[index].classList.contains('not-collapsable'))
                tooltips[index].classList.toggle('active', index === tooltipIndex);
        }
    }
    function scrollSubTooltipIntoView(tooltipIndex, animate = false) {
        const tooltips = tooltip.children[tooltipIndex];
        tooltip.style.transition = animate ? 'transform 0.25s' : '';
        tooltip.style.transform = `translate(0, -${tooltips.offsetTop + tooltips.offsetHeight}px)`;
    }
    function positionTooltip(animate = false) {
        const wpadminbar = document.getElementById('wpadminbar');
        const topBarHeight = wpadminbar ? wpadminbar.offsetHeight : 0;
        const marginX = 22;
        const marginY = 13;
        const offsetX = 6;
        const offsetY = 6;
        const currentSubTooltip = tooltip.children[cyclePos];
        let tooltipXpos = lastMouseX + offsetX;
        if (tooltipXpos + tooltip.offsetWidth > document.documentElement.clientWidth - marginX) {
            tooltipXpos = document.documentElement.clientWidth - (tooltip.offsetWidth + marginX);
        }
        let tooltipYpos = lastMouseY - offsetY;
        if (tooltipYpos - currentSubTooltip.offsetHeight < document.documentElement.scrollTop + topBarHeight + marginY) {
            if (animate) {
                tooltip.style.transition += ', top 0.25s';
                setTimeout(() => tooltip.style.transition = '', 250);
            }
            tooltipYpos = document.documentElement.scrollTop + topBarHeight + marginY + currentSubTooltip.offsetHeight;
        }
        tooltip.style.left = `${tooltipXpos}px`;
        tooltip.style.top = `${tooltipYpos}px`;
    }
    async function hookDocument(scope, _unused) {
        const objectsToGet = {
            skills: new Map(),
            traits: new Map(),
            items: new Map(),
            specializations: new Map(),
            pets: new Map(),
            'pvp/amulets': new Map(),
            attributes: new Map(),
        };
        const statsToGet = new Set();
        const _legacy_effectErrorStore = new Set();
        for (const gw2Object of scope.getElementsByTagName('gw2object')) {
            const stats = +String(gw2Object.getAttribute('stats'));
            if (!isNaN(stats))
                statsToGet.add(stats);
            let objId_raw = gw2Object.getAttribute('objId');
            let type = (gw2Object.getAttribute('type') || 'skill') + 's';
            if (type === 'attributes') {
                if (typeof objId_raw === 'string') {
                    const elementsWithThisId = objectsToGet.attributes.get(objId_raw);
                    if (elementsWithThisId)
                        elementsWithThisId.push(gw2Object);
                    else
                        objectsToGet.attributes.set(objId_raw, [gw2Object]);
                }
            }
            else {
                let objId = +String(objId_raw);
                if (type === 'effects') {
                    if (exports.config.legacyCompatibility) {
                        type = 'skills';
                        objId = _legacy_transformEffectToSkillObject(gw2Object, _legacy_effectErrorStore);
                    }
                    else {
                        continue;
                    }
                }
                if (!isNaN(objId) && type in objectsToGet) {
                    const elementsWithThisId = objectsToGet[type].get(objId);
                    if (elementsWithThisId)
                        elementsWithThisId.push(gw2Object);
                    else
                        objectsToGet[type].set(objId, [gw2Object]);
                }
                else {
                    continue;
                }
            }
            attachMouseListeners(gw2Object);
        }
        if (_legacy_effectErrorStore.size) {
            console.error("[gw2-tooltips] [legacy-compat] Some effects could not be translated into skills: ", Array.from(_legacy_effectErrorStore));
        }
        if (statsToGet.size > 0)
            APICache.ensureExistence('itemstats', statsToGet.values());
        await Promise.all(Object.entries(objectsToGet)
            .filter(([key, _]) => key != 'attributes')
            .map(async ([key, values]) => {
            if (values.size == 0)
                return;
            let inflator;
            switch (key) {
                case 'skills':
                    inflator = inflateSkill;
                    break;
                case 'items':
                    inflator = inflateItem;
                    break;
                case 'specializations':
                    inflator = inflateSpecialization;
                    break;
                default:
                    inflator = inflateGenericIcon;
                    break;
            }
            const cache = APICache.storage[key];
            await APICache.ensureExistence(key, values.keys());
            for (const [id, objects] of values) {
                const data = cache.get(id);
                if (!objects || !data)
                    continue;
                for (const gw2Object of objects)
                    inflator(gw2Object, data);
            }
        }));
        return objectsToGet;
    }
    function attachMouseListeners(target) {
        target.addEventListener('mouseenter', (e) => showTooltipFor(e.target));
        target.addEventListener('mouseleave', () => {
            tooltip.style.display = 'none';
            tooltip.style.transform = '';
        });
    }
    function showTooltipFor(gw2Object, visibleIndex = 0) {
        const type = ((gw2Object.getAttribute('type') || 'skill') + 's');
        const objId = gw2Object.getAttribute('objId');
        let context = contexts[+String(gw2Object.getAttribute('contextSet')) || 0];
        const statSetId = +String(gw2Object.getAttribute('stats')) || undefined;
        const stackSize = +String(gw2Object.getAttribute('count')) || undefined;
        if (type == 'specializations' || type == 'effects')
            return;
        lastTooltipTarget = gw2Object;
        if (type == 'attributes') {
            if (objId) {
                cyclePos = visibleIndex;
                tooltip.replaceChildren(generateAttributeTooltip(objId, context));
                tooltip.style.display = '';
                for (const tt of tooltip.children)
                    tt.classList.add('active');
                scrollSubTooltipIntoView(cyclePos);
            }
            return;
        }
        const data = APICache.storage[type].get(+String(objId));
        if (data) {
            cyclePos = visibleIndex;
            const ogContext = context;
            context = specializeContextFromInlineAttribs(context, gw2Object);
            if ('palettes' in data) {
                if (context.underwater) {
                    if (!data.flags.includes('UsableUnderWater') && data.flags.includes('UsableLand')) {
                        if (context == ogContext)
                            context = Object.assign({}, context);
                        context.underwater = false;
                    }
                }
                else if (!context.underwater) {
                    if (!data.flags.includes('UsableLand') && data.flags.includes('UsableUnderWater')) {
                        if (context == ogContext)
                            context = Object.assign({}, context);
                        context.underwater = true;
                    }
                }
            }
            tooltip.replaceChildren(...generateToolTipList(data, gw2Object, context, statSetId, stackSize));
            tooltip.style.display = '';
            if (Array.from(tooltip.children).filter(tt => !tt.classList.contains('not-collapsable')).length > 1) {
                gw2Object.classList.add('cycler');
                gw2Object.title = 'Right-click to cycle through tooltips';
                activateSubTooltip(cyclePos);
            }
            else {
                for (const tt of tooltip.children)
                    tt.classList.add('active');
            }
            scrollSubTooltipIntoView(cyclePos);
        }
    }
    function getSlotName(skill) {
        let skillSlot;
        for (const pid of skill.palettes) {
            const palette = APICache.storage.palettes.get(pid);
            if (!palette) {
                console.warn(`[gw2-tooltips] [slot-name] Palette #${pid} is missing from the cache. The query was caused by `, skill);
                continue;
            }
            for (const { slot, candidates } of palette.groups) {
                if (!candidates.some(c => c.skill == skill.id))
                    continue;
                switch (palette.type) {
                    case 'Equipment':
                    case 'Bundle':
                        if (palette.weapon_type || palette.type == 'Bundle') {
                            skillSlot = slot.replace(/(Offhand|Main)(\d)/, (_, hand, digit) => {
                                if (hand == 'Offhand') {
                                    digit = digit === '1' ? '4' : '5';
                                }
                                return `${palette.weapon_type ? mapLocale(palette.weapon_type) : 'Bundle'} ${digit}`;
                            });
                        }
                        break;
                    case 'Standard':
                        if (slot === 'Standard') {
                            skillSlot = 'Utility';
                        }
                        break;
                    case 'Heal':
                    case 'Toolbelt':
                    case 'Elite':
                        skillSlot = palette.type;
                        break;
                    case 'Pet':
                    case 'Profession':
                    case 'Transformation':
                        skillSlot = slot.replace(/(\S+?)(\d)/, "$1 $2");
                        break;
                    case 'Monster':
                        break;
                    default:
                        console.error(`[gw2-tooltips] [tooltip engine] unknown palette type '${palette.type}' for skill '${skill.name}'`);
                }
            }
        }
        return skillSlot;
    }
    function generateToolTip(apiObject, notCollapsable, iconMode, context, weaponSet) {
        var _a;
        const headerElements = [];
        if (iconMode == 1 || (iconMode == 2 && !IsDevIcon(apiObject.icon)))
            headerElements.push(newImg(apiObject.icon));
        headerElements.push(newElm('teb', fromHTML(GW2Text2HTML(resolveInflections(apiObject.name, 1, context.character)))), newElm('div.flexbox-fill'));
        const currentContextInformation = resolveTraitsAndOverrides(apiObject, context);
        if ('flags' in apiObject && apiObject.flags.includes('DisallowUnderwater')) {
            headerElements.push(newImg(ICONS.NO_UNDERWATER, 'iconsmall'));
        }
        if (currentContextInformation.activation) {
            const value = drawFractional(currentContextInformation.activation / 1000, exports.config);
            if (value != '0') {
                headerElements.push(newElm('ter', value, newImg(ICONS.ACTIVATION, 'iconsmall')));
            }
        }
        if (currentContextInformation.resource_cost) {
            headerElements.push(newElm('ter', String(currentContextInformation.resource_cost), newImg(context.character.profession == 'Revenant' ? ICONS.RESOURCE_REV : ICONS.RESOURCE_THIEF, 'iconsmall')));
        }
        if (currentContextInformation.endurance_cost) {
            headerElements.push(newElm('ter', String(Math.round(currentContextInformation.endurance_cost)), newImg(ICONS.ENDURANCE_COST, 'iconsmall')));
        }
        if (currentContextInformation.upkeep_cost) {
            headerElements.push(newElm('ter', String(currentContextInformation.upkeep_cost), newImg(ICONS.UPKEEP_COST, 'iconsmall')));
        }
        if (currentContextInformation.recharge) {
            const value = drawFractional(currentContextInformation.recharge / 1000, exports.config);
            if (value != '0') {
                headerElements.push(newElm('ter', value, newImg(ICONS.RECHARGE, 'iconsmall')));
            }
        }
        if (currentContextInformation.supply_cost) {
            headerElements.push(newElm('ter', String(currentContextInformation.supply_cost), newImg(ICONS.SUPPLY_COST, 'iconsmall')));
        }
        const secondHeaderRow = [];
        {
            let slotName = ('slot' in apiObject && apiObject.slot) || ('palettes' in apiObject && getSlotName(apiObject));
            if ('specialization' in apiObject)
                slotName = (((_a = APICache.storage.specializations.get(apiObject.specialization)) === null || _a === void 0 ? void 0 : _a.name) || apiObject.specialization) + ' - ' + slotName;
            if (slotName)
                secondHeaderRow.push(newElm('tes', `( ${slotName} )`));
            if (weaponSet !== undefined)
                secondHeaderRow.push(newElm('tes', `( Weapon Set ${weaponSet + 1} )`));
        }
        secondHeaderRow.push(newElm('div.flexbox-fill'));
        if ('override_groups' in apiObject && apiObject.override_groups) {
            const baseContext = new Set(['Pve', 'Pvp', 'Wvw']);
            for (const override of apiObject.override_groups) {
                for (const context of override.context) {
                    baseContext.delete(context);
                }
            }
            const splits = [Array.from(baseContext), ...apiObject.override_groups.map(o => o.context)];
            const splits_html = [];
            for (const mode of ['Pve', 'Pvp', 'Wvw']) {
                let split;
                for (let i = 0; i < splits.length; i++) {
                    if (splits[i].includes(mode)) {
                        split = splits.splice(i, 1)[0];
                        break;
                    }
                }
                if (!split)
                    continue;
                const text = split.join('/');
                if (split.includes(context.gameMode))
                    splits_html.push(`<span style="color: var(--gw2-tt-color-text-accent) !important;">${text}</span>`);
                else
                    splits_html.push(text);
            }
            secondHeaderRow.push(newElm('tes', '( ', fromHTML(splits_html.join(' | ')), ' )'));
        }
        const parts = [newElm('tet.title', ...headerElements)];
        if (secondHeaderRow.length > 1)
            parts.push(newElm('tet.detail', ...secondHeaderRow));
        if ('description' in apiObject && apiObject.description) {
            parts.push(newElm('p.description', fromHTML(GW2Text2HTML(apiObject.description))));
        }
        if (currentContextInformation.blocks) {
            let weaponStrength = 690.5;
            if ('palettes' in apiObject)
                for (const pid of apiObject.palettes) {
                    const palette = APICache.storage.palettes.get(pid);
                    if (!palette)
                        continue;
                    const criteria = context.character.profession
                        ? ((s) => s.profession === context.character.profession)
                        : ((s) => s.profession);
                    if (palette.groups.some(criteria)) {
                        weaponStrength = getWeaponStrength(palette);
                        break;
                    }
                }
            parts.push(...generateFacts(currentContextInformation.blocks, weaponStrength, context));
        }
        const tooltip = newElm('div.tooltip', ...parts);
        if (notCollapsable)
            tooltip.classList.add('not-collapsable');
        tooltip.dataset.id = String(apiObject.id);
        return tooltip;
    }
    function resolveTraitsAndOverrides(apiObject, context) {
        var _a, _b, _c, _d, _e;
        let override = (_a = apiObject.override_groups) === null || _a === void 0 ? void 0 : _a.find(g => g.context.includes(context.gameMode));
        let result = Object.assign({}, apiObject, override);
        result.blocks = structuredClone(apiObject.blocks);
        if (!result.blocks)
            return result;
        if (override === null || override === void 0 ? void 0 : override.blocks) {
            const end = Math.max(result.blocks.length, override.blocks.length);
            for (let blockId = 0; blockId < end; blockId++) {
                let baseBlock = result.blocks[blockId];
                const overrideBlock = override.blocks[blockId];
                if (overrideBlock) {
                    if (!baseBlock) {
                        baseBlock = result.blocks[blockId] = {
                            description: overrideBlock.description,
                            trait_requirements: overrideBlock.trait_requirements,
                        };
                    }
                    if (!overrideBlock.facts)
                        continue;
                    const facts = result.blocks[blockId].facts = (_b = baseBlock.facts) !== null && _b !== void 0 ? _b : [];
                    for (const fact of overrideBlock.facts) {
                        if ((_c = fact.requires_trait) === null || _c === void 0 ? void 0 : _c.some(t => !context.character.traits.includes(t)))
                            continue;
                        if (fact.insert_before !== undefined) {
                            if (fact.skip_next)
                                fact.__gamemode_override_marker = true;
                            facts.splice(fact.insert_before, 0, fact);
                        }
                        else
                            facts.push(fact);
                    }
                }
            }
        }
        const finalBlocks = [];
        for (const block of result.blocks) {
            if ((_d = block.trait_requirements) === null || _d === void 0 ? void 0 : _d.some(t => !context.character.traits.includes(t)))
                continue;
            if (block.facts) {
                const finalFacts = [];
                let to_skip = 0;
                for (let i = 0; i < block.facts.length; i++) {
                    const fact = block.facts[i];
                    if ((_e = fact.requires_trait) === null || _e === void 0 ? void 0 : _e.some(t => !context.character.traits.includes(t)))
                        continue;
                    if (to_skip-- > 0)
                        continue;
                    finalFacts.push(fact);
                    to_skip = fact.skip_next || 0;
                }
                block.facts = finalFacts;
            }
            finalBlocks.push(block);
        }
        result.blocks = finalBlocks;
        return result;
    }
    function getWeaponStrength({ weapon_type, type: palette_type }) {
        if (!weapon_type) {
            if (palette_type === 'Bundle') {
                return 922.5;
            }
            return 690.5;
        }
        else {
            return {
                BundleLarge: 0,
                Standard: 690.5,
                Focus: 900,
                Shield: 900,
                Torch: 900,
                Warhorn: 900,
                Greatsword: 1100,
                Hammer: 1100,
                Staff: 1100,
                BowLong: 1050,
                Rifle: 1150,
                BowShort: 1000,
                Axe: 1000,
                Sword: 1000,
                Dagger: 1000,
                Pistol: 1000,
                Scepter: 1000,
                Mace: 1000,
                Spear: 1000,
                Speargun: 1000,
                Trident: 1000,
            }[weapon_type];
        }
    }
    function generateToolTipList(initialAPIObject, gw2Object, context, statSetId, stackSize) {
        let subiconRenderMode = 1;
        if ((gw2Object.getAttribute('type') || 'skill') == 'trait')
            subiconRenderMode = 2;
        else if (initialAPIObject.name.includes('Relic[s] of'))
            subiconRenderMode = 0;
        const objectChain = [];
        const adjustTraitedSkillIds = gw2Object.classList.contains('auto-transform');
        {
            if ('palettes' in initialAPIObject) {
                if (adjustTraitedSkillIds) {
                    const replacementSkill = findTraitedOverride(initialAPIObject, context);
                    if (replacementSkill)
                        initialAPIObject = replacementSkill;
                }
                let group, i;
                [group, i, context] = findMostLikelyGroupAndContext(initialAPIObject, context);
                if (group) {
                    let candidate = group.candidates[i];
                    const insertAtIndex = objectChain.length;
                    while (candidate.previous_chain_skill_index) {
                        const otherCandidate = group.candidates[candidate.previous_chain_skill_index];
                        if (!canBeSelected(otherCandidate, context))
                            break;
                        let skill = APICache.storage.skills.get(otherCandidate.skill);
                        if (!skill) {
                            console.warn(`[gw2-tooltips] Chain skill #${otherCandidate.skill} is missing from the cache. The query was caused by `, gw2Object);
                            skill = MISSING_SKILL;
                        }
                        objectChain.splice(insertAtIndex, 0, { obj: skill, notCollapsable: false, iconMode: subiconRenderMode });
                        candidate = otherCandidate;
                    }
                }
                objectChain.push({ obj: initialAPIObject, notCollapsable: false, iconMode: 1 });
                for (let j = 0; j < i; j++) {
                    const otherCandidate = group.candidates[j];
                    if (otherCandidate.previous_chain_skill_index != i)
                        continue;
                    if (!canBeSelected(otherCandidate, context))
                        continue;
                    let skill = APICache.storage.skills.get(otherCandidate.skill);
                    if (!skill) {
                        console.warn(`[gw2-tooltips] Chain skill #${otherCandidate.skill} is missing from the cache. The query was caused by `, gw2Object);
                        skill = MISSING_SKILL;
                    }
                    objectChain.push({ obj: skill, notCollapsable: false, iconMode: subiconRenderMode });
                    i = j;
                    j = -1;
                }
            }
            else {
                objectChain.push({ obj: initialAPIObject, notCollapsable: false, iconMode: 1 });
            }
            if ('bundle_skills' in initialAPIObject) {
                for (const subSkillId of initialAPIObject.bundle_skills) {
                    const subSkillInChain = APICache.storage.skills.get(subSkillId);
                    if (subSkillInChain && canBeUsedOnCurrentTerrain(subSkillInChain, context)) {
                        objectChain.push({ obj: subSkillInChain, notCollapsable: false, iconMode: subiconRenderMode });
                    }
                }
            }
            if ('related_skills' in initialAPIObject) {
                const type = gw2Object.getAttribute('type') || 'skill';
                for (const subSkillId of initialAPIObject.related_skills) {
                    const subSkillInChain = APICache.storage.skills.get(subSkillId);
                    if (subSkillInChain && canBeUsedOnCurrentTerrain(subSkillInChain, context) && ((type != 'skill') || subSkillInChain.palettes.some(pid => {
                        const palette = APICache.storage.palettes.get(pid);
                        return palette && VALID_CHAIN_PALETTES.includes(palette.type);
                    }))) {
                        objectChain.push({ obj: subSkillInChain, notCollapsable: false, iconMode: subiconRenderMode });
                    }
                }
            }
            if ('ambush_skills' in initialAPIObject) {
                for (const { id: subSkillId, spec } of initialAPIObject.ambush_skills) {
                    const subSkillInChain = APICache.storage.skills.get(subSkillId);
                    if (subSkillInChain && canBeUsedOnCurrentTerrain(subSkillInChain, context) && (!spec || context.character.specializations.includes(spec))) {
                        objectChain.push({ obj: subSkillInChain, notCollapsable: false, iconMode: subiconRenderMode });
                        break;
                    }
                }
            }
            if ('skills' in initialAPIObject)
                for (const petSkillId of initialAPIObject.skills) {
                    let petSkill = APICache.storage.skills.get(petSkillId);
                    if (!petSkill) {
                        console.warn(`[gw2-tooltips] pet skill #${petSkillId} is missing from the cache. The query was caused by `, gw2Object);
                        petSkill = MISSING_SKILL;
                    }
                    objectChain.push({ obj: petSkill, notCollapsable: true, iconMode: subiconRenderMode });
                }
        }
        let weaponSet = +String(gw2Object.getAttribute('weaponSet'));
        if (isNaN(weaponSet))
            weaponSet = undefined;
        const tooltipChain = objectChain.map(({ obj, notCollapsable, iconMode }) => (('type' in obj) ? generateItemTooltip(obj, context, gw2Object, statSetId, stackSize) : generateToolTip(obj, notCollapsable, iconMode, context, weaponSet)));
        tooltip.append(...tooltipChain);
        return tooltipChain;
    }
    function findMostLikelyGroupAndContext(skill, context) {
        let fallback = undefined;
        for (const pid of skill.palettes) {
            const palette = APICache.storage.palettes.get(pid);
            if (!palette) {
                console.warn(`[gw2-tooltips] Palette #${pid} is missing from the cache. The query was caused by `, skill);
                continue;
            }
            if (!VALID_CHAIN_PALETTES.includes(palette.type))
                continue;
            for (const group of palette.groups) {
                if (context.character.profession && group.profession && group.profession != context.character.profession)
                    continue;
                for (const [i, candidate] of group.candidates.entries()) {
                    if (candidate.skill != skill.id)
                        continue;
                    if (!fallback)
                        fallback = [group, i, context];
                    if (canBeSelected(candidate, context))
                        return [group, i, context];
                }
            }
        }
        if (fallback) {
            fallback[2] = transmuteContext(fallback[0].candidates[fallback[1]], context);
            return fallback;
        }
        for (const pid of skill.palettes) {
            const palette = APICache.storage.palettes.get(pid);
            if (!palette)
                continue;
            if (!VALID_CHAIN_PALETTES.includes(palette.type))
                continue;
            for (const group of palette.groups) {
                for (const [i, candidate] of group.candidates.entries()) {
                    if (candidate.skill == skill.id)
                        return [group, i, transmuteContext(candidate, context)];
                }
            }
        }
        for (const pid of skill.palettes) {
            const palette = APICache.storage.palettes.get(pid);
            if (!palette)
                continue;
            for (const group of palette.groups) {
                for (const [i, candidate] of group.candidates.entries()) {
                    if (candidate.skill == skill.id)
                        return [group, i, transmuteContext(candidate, context)];
                }
            }
        }
        return [undefined, -1, context];
    }
    function transmuteContext(targetCandidate, context, clone = true) {
        if (clone) {
            const character = Object.assign({}, context.character, { specializations: context.character.specializations.slice(), traits: context.character.traits.slice() });
            context = Object.assign({}, context, { character });
        }
        if (targetCandidate.specialization && !context.character.specializations.includes(targetCandidate.specialization))
            context.character.specializations.push(targetCandidate.specialization);
        if (targetCandidate.trait && !context.character.traits.includes(targetCandidate.trait))
            context.character.traits.push(targetCandidate.trait);
        return context;
    }
    function canBeSelected(info, context) {
        return (info.specialization === undefined || context.character.specializations.includes(info.specialization)) &&
            (info.trait === undefined || context.character.traits.includes(info.trait)) &&
            (context.underwater ? info.usability.includes('UsableUnderWater') : info.usability.includes('UsableLand')) &&
            (context.character.level >= (info.min_level || 0));
    }
    function canBeUsedOnCurrentTerrain(skill, context) {
        return context.underwater ? skill.flags.includes('UsableUnderWater') : skill.flags.includes('UsableLand');
    }
    function findTraitedOverride(skill, context) {
        var _a;
        for (const pid of skill.palettes) {
            const palette = APICache.storage.palettes.get(pid);
            if (!palette) {
                console.warn(`[gw2-tooltips] Palette #${pid} is missing from the cache. The query was caused by `, skill);
                continue;
            }
            for (const group of palette.groups) {
                if (context.character.profession && group.profession && group.profession != context.character.profession)
                    continue;
                const end = group.candidates.findIndex(c => c.skill == skill.id);
                if (end == -1)
                    continue;
                for (let i = 0; i < end; i++) {
                    const candidate = group.candidates[i];
                    if (candidate.trait) {
                        if (!context.character.traits.includes(candidate.trait))
                            continue;
                        const replacementSkill = APICache.storage.skills.get(candidate.skill);
                        if (!replacementSkill) {
                            console.error(`[gw2-tooltips] Corrected skill #${candidate.skill} is missing in the cache.`);
                            return;
                        }
                        else {
                            console.info(`[gw2-tooltips] Corrected skill #${skill.id} (${skill.name}) to #${replacementSkill.id} (${replacementSkill.name}) because the trait #${candidate.trait} (${((_a = APICache.storage.traits.get(candidate.trait)) === null || _a === void 0 ? void 0 : _a.name) || '<not cached>'}) is active.`);
                            return replacementSkill;
                        }
                    }
                }
            }
        }
        return;
    }
    function generateItemTooltip(item, context, target, statSetId, stackSize = 1) {
        var _a;
        let statSet = findCorrectAttributeSet(item, statSetId);
        let slottedItems;
        if ('slots' in item) {
            slottedItems = (_a = target.getAttribute('slotted')) === null || _a === void 0 ? void 0 : _a.split(',').map(id => APICache.storage.items.get(+String(id) || 0)).filter(i => i && 'subtype' in i);
        }
        const countPrefix = stackSize > 1 ? stackSize + ' ' : '';
        const upgradeNameSource = (slottedItems === null || slottedItems === void 0 ? void 0 : slottedItems.find(i => !['Infusion', 'Enrichment'].includes(i.subtype))) || (slottedItems === null || slottedItems === void 0 ? void 0 : slottedItems[0]);
        const name = countPrefix + formatItemName(item, context, statSet, upgradeNameSource, stackSize);
        const parts = [newElm('tet.title', newImg(item.icon), newElm('teb.gw2-color-rarity-' + item.rarity.toLowerCase(), name), newElm('div.flexbox-fill'))];
        if ('defense' in item && item.defense) {
            const defense = (typeof item.defense == "number")
                ? item.defense
                : LUT_DEFENSE[Math.min(100, (item.defense[0] + context.character.level))] * item.defense[1];
            parts.push(newElm('te', newElm('tem', 'Defense: ', newElm('span.gw2-color-stat-green', String(Math.ceil(defense))))));
        }
        if ('power' in item) {
            let power;
            if ('mul' in item.power) {
                let maxRarity = Rarity.Legendary;
                if (['PlayerLevelScaleRarity', 'ItemScale4'].includes(item.power.scaling)) {
                    if (context.character.level < 14)
                        maxRarity = Rarity.Common;
                    else if (context.character.level < 30)
                        maxRarity = Rarity.Uncommon;
                    else if (context.character.level < 60)
                        maxRarity = Rarity.Rare;
                    else if (context.character.level < 80)
                        maxRarity = Rarity.Exotic;
                }
                const rarity = Math.min(Rarity[item.rarity], maxRarity);
                let index = LUT_RARITY[rarity];
                if (!item.power.scaling)
                    index += item.level;
                else {
                    index += context.character.level;
                }
                const avg = (context.character.isPlayer ? LUT_POWER_PLAYER : LUT_POWER_MONSTER)[Math.min(100, index)] * item.power.mul * LUT_RARITY_MUL[rarity];
                const spread = avg * item.power.spread;
                power = [Math.ceil(avg - spread), Math.ceil(avg + spread)];
            }
            else {
                power = item.power;
            }
            const line = newElm('tem', 'Weapon Strength: ', newElm('span.gw2-color-stat-green', `${power[0]} - ${power[1]}`));
            if (item.damage_type)
                line.append(` (${item.damage_type})`);
            parts.push(newElm('te', line));
        }
        if ('tiers' in item) {
            parts.push(generateUpgradeItemGroup(item, context));
        }
        if (statSet && 'attribute_base' in item) {
            parts.push(...statSet.attributes.map(({ attribute, base_value, scaling }) => {
                const computedValue = Math.round(base_value + item.attribute_base * scaling);
                return newElm('te', newElm('tem.gw2-color-stat-green', `+${computedValue} ${mapLocale(attribute)}`));
            }));
        }
        if ('slots' in item) {
            parts.push(newElm('div.group.slots', ...item.slots.map(s => {
                let slottedItemIdx = -1;
                if (slottedItems) {
                    switch (s) {
                        case 'Upgrade':
                            slottedItemIdx = slottedItems.findIndex(i => ['Rune', 'Sigil', 'Gem'].includes(i.subtype));
                            break;
                        case 'Infusion':
                            slottedItemIdx = slottedItems.findIndex(i => i.subtype == 'Infusion');
                            break;
                        case 'Enrichment':
                            slottedItemIdx = slottedItems.findIndex(i => i.subtype == 'Enrichment');
                            break;
                    }
                }
                if (slottedItemIdx > -1) {
                    const slottedItem = slottedItems.splice(slottedItemIdx, 1)[0];
                    const group = generateUpgradeItemGroup(slottedItem, context);
                    const name = formatItemName(slottedItem, context, statSet);
                    group.prepend(newElm('tet', newImg(slottedItem.icon, 'iconsmall'), newElm('teb.gw2-color-rarity-' + slottedItem.rarity, name), newElm('div.flexbox-fill')));
                    return group;
                }
                else {
                    return newElm('te', newImg(ICONS['SLOT_' + s], 'iconsmall'), `Empty ${s} Slot`);
                }
            })));
        }
        let descriptionAlreadyShown = false;
        if ('applies_buff' in item) {
            parts.push(newElm('span', fromHTML(GW2Text2HTML(item.description))));
            parts.push(newElm('div.group', generateFact(item.applies_buff, -1, context, true).wrapper));
            descriptionAlreadyShown = true;
        }
        const metaInfo = newElm('div.group');
        if (item.type == "Armor" || item.type == "Weapon" || (item.type == "Trinket" && !item.flags.includes('Pvp'))) {
            metaInfo.append(newElm('span.gw2-color-rarity-' + item.rarity, item.rarity));
            if ('weight' in item)
                metaInfo.append(newElm('span', item.weight));
            metaInfo.append(newElm('span', `${item.type}: ${item.subtype}`));
            if (item.type == "Weapon" && isTwoHanded(item.subtype))
                metaInfo.append(newElm('span.gw2-color-rarity-Junk', `(Two-Handed)`));
            if (item.required_level)
                metaInfo.append(newElm('span', 'Required Level: ' + item.required_level));
        }
        if (item.description && !descriptionAlreadyShown)
            metaInfo.append(newElm('span', fromHTML(GW2Text2HTML(item.description))));
        if (!item.flags.includes('Pvp')) {
            if (item.flags.includes('Unique'))
                metaInfo.append(newElm('span', 'Unique'));
            if (item.flags.includes('AccountBound'))
                metaInfo.append(newElm('span', 'Account Bound'));
            if (item.flags.includes('SoulBindOnUse'))
                metaInfo.append(newElm('span', 'Soulbound on Use'));
            else if (item.flags.includes('SoulBindOnAcquire'))
                metaInfo.append(newElm('span', 'Soulbound on Acquire'));
        }
        if (!item.flags.includes('NoSalvage')) {
            const salvageOptions = [item.type == 'Consumable' && item.subtype == 'Food'
                    ? 'Compost'
                    : item.rarity == 'Ascended' ? 'Ascended' : 'Standard'
            ];
            if (item.flags.includes('SalvageResearch'))
                salvageOptions.push('Research');
            if (salvageOptions.length)
                metaInfo.append(newElm('span', 'Salvage: ' + salvageOptions.join(', ')));
        }
        if (item.vendor_value) {
            let inner = ['Vendor Value: ', formatCoins(item.vendor_value * stackSize)];
            if (stackSize > 1)
                inner.push(' (', formatCoins(item.vendor_value), ` x ${stackSize})`);
            metaInfo.append(newElm('span', ...inner));
        }
        parts.push(metaInfo);
        const tooltip = newElm('div.tooltip.item.active', ...parts);
        tooltip.dataset.id = String(item.id);
        return tooltip;
    }
    function findCorrectAttributeSet(item, statSetId) {
        let statSet = undefined;
        if (item.type == "Armor" || item.type == "Trinket" || item.type == "Weapon") {
            statSetId = statSetId || item.attribute_set;
            if (statSetId === undefined)
                console.warn(`[gw2-tooltips] [tooltip engine] Hovering on item without specified or innate stats. Specify the stats by adding 'stats="<stat_set_id>" to the html element.' `);
            else {
                statSet = APICache.storage.itemstats.get(statSetId);
                if (!statSet)
                    console.error(`[gw2-tooltips] [tooltip engine] itemstat #${statSetId} is missing in cache.`);
                else {
                    if (exports.config.adjustIncorrectStatIds && statSet.similar_sets) {
                        const correctSetId = statSet.similar_sets[item.subtype];
                        if (correctSetId !== undefined) {
                            console.info(`[gw2-tooltips] [tooltip engine] Corrected itemstat #${statSetId} to #${correctSetId} because the target is of type ${item.subtype}.`);
                            const newSet = APICache.storage.itemstats.get(correctSetId);
                            if (!newSet)
                                console.error(`[gw2-tooltips] [tooltip engine] Corrected itemstat #${correctSetId} is missing in the cache.`);
                            else
                                statSet = newSet;
                        }
                    }
                }
            }
        }
        return statSet;
    }
    function generateUpgradeItemGroup(item, context) {
        const group = newElm('div.group');
        for (const [i, tier] of item.tiers.entries()) {
            let tier_wrap = newElm('te');
            if (tier.description)
                tier_wrap.append(newElm('span', fromHTML(GW2Text2HTML(tier.description))));
            else if (tier.facts) {
                for (const fact of tier.facts) {
                    const { wrapper } = generateFact(fact, null, context);
                    if (wrapper)
                        tier_wrap.append(wrapper);
                }
            }
            else if (tier.modifiers) {
                tier_wrap.style.flexDirection = "column";
                const activeAttributes = getActiveAttributes(context.character);
                for (const modifier of tier.modifiers) {
                    let modifierValue = calculateModifier(modifier, context.character.level, activeAttributes);
                    let text;
                    if (modifier.flags.includes('FormatPercent')) {
                        text = `+${Math.round(modifierValue)}% ${mapLocale(modifier.description)}`;
                    }
                    else {
                        text = `+${Math.round(modifierValue)} ${mapLocale(modifier.description)}`;
                    }
                    tier_wrap.append(newElm('te', text));
                }
            }
            const w = newElm('te', tier_wrap);
            if (item.subtype == "Rune") {
                const colorClass = i < (context.character.upgradeCounts[item.id] || 0) ? '.gw2-color-stat-green' : '';
                w.prepend(newElm('span' + colorClass, `(${i + 1})`));
            }
            group.append(w);
        }
        return group;
    }
    function generateAttributeTooltip(attribute, context) {
        const weaponStats = context.character.statsWithWeapons[context.character.selectedWeaponSet];
        const value = weaponStats.values[attribute];
        let parts = weaponStats.htmlParts[attribute];
        if (['ConditionDuration', 'BoonDuration'].includes(attribute)) {
            parts = parts.slice();
            const target_type = attribute === 'ConditionDuration' ? 'Condition' : 'Boon';
            const completeSources = structuredClone(context.character.stats.sources);
            for (const [key, mods] of Object.entries(weaponStats.sources)) {
                if (isNaN(+key))
                    continue;
                (completeSources[key] || (completeSources[key] = [])).push(...mods);
            }
            const modCap = (getAttributeInformation(attribute, context.character).cap - 1) * 100;
            const activeAttributes = getActiveAttributes(context.character);
            for (const [effect_id, sources] of Object.entries(completeSources)) {
                if (isNaN(+effect_id))
                    continue;
                const effect = APICache.storage.skills.get(+effect_id);
                if (!effect) {
                    console.error(`[gw2-tooltips] [tooltip engine] effect #${effect_id} is missing in cache.`);
                    continue;
                }
                if (effect.buff_type !== target_type)
                    continue;
                let specificMod = value * 100;
                let specificParts = [];
                for (const { source, modifier, count } of sources) {
                    const mod = calculateModifier(modifier, context.character.level, activeAttributes);
                    specificParts.push(newElm('span.detail', `${mod > 0 ? '+' : ''}${n3(mod)}% from ${count > 1 ? `${count} ` : ''}`, fromHTML(resolveInflections(source, count, context.character))));
                    specificMod += mod;
                }
                const uncappedMod = specificMod;
                specificMod = Math.min(specificMod, modCap);
                if (uncappedMod != specificMod) {
                    specificParts.push(newElm('span.detail.capped', `(Capped to +${n3(specificMod)}%! Uncapped value would be ${n3(uncappedMod)}%)`));
                }
                parts.push(newElm('div.fact', newImg(effect.icon), newElm('div', newElm('span', `${effect.name}: +${n3(specificMod)}%`), ...specificParts)));
            }
        }
        return newElm('div.tooltip.item.active', ...parts);
    }
    function formatItemName(item, context, statSet, upgradeComponent, stackSize = 1) {
        let name;
        if (item.type == 'TraitGuide') {
            name = item.trait;
        }
        else {
            name = item.name;
        }
        let arg1, arg2, arg3, arg4;
        arg1 = arg2 = arg3 = arg4 = '';
        if (!item.flags.includes('HidePrefix')) {
            if (statSet && statSet.name) {
                arg1 = statSet.name;
                arg2 = " ";
            }
        }
        if (!item.flags.includes('HideSuffix')) {
            if (upgradeComponent && upgradeComponent.suffix) {
                arg4 = upgradeComponent.suffix;
                arg3 = " ";
            }
        }
        name = GW2Text2HTML(name, arg1, arg2, arg3, arg4);
        if (stackSize > -1)
            name = resolveInflections(name, stackSize, context.character);
        if (!item.flags.includes('Pve') && (item.flags.includes('Pvp') || item.flags.includes('PvpLobby')))
            name += " (PvP)";
        return name;
    }
    function specializeContextFromInlineAttribs(context, gw2Object) {
        let traitOverrides = gw2Object.getAttribute('with-traits');
        if (traitOverrides) {
            context = Object.assign({}, context);
            context.character = Object.assign({}, context.character);
            const invalid = [];
            context.character.traits = traitOverrides.split(',').map(t => {
                const v = +t;
                if (!v)
                    invalid.push(t);
                return v;
            }).filter(t => t);
            if (invalid.length)
                console.warn("[gw2-tooltips] [tooltip engine] Inline trait-override for element ", gw2Object, " has misformed overrides: ", invalid);
        }
        return context;
    }
    function formatCoins(amount) {
        const parts = [String(Math.floor(amount % 100)), newImg(ICONS.COIN_COPPER, 'iconsmall', '')];
        if (amount > 99)
            parts.unshift(String(Math.floor((amount / 100) % 100)), newImg(ICONS.COIN_SILVER, 'iconsmall', ''));
        if (amount > 9999)
            parts.unshift(String(Math.floor(amount / 10000)), newImg(ICONS.COIN_GOLD, 'iconsmall', ''));
        return newElm('span', ...parts);
    }
    function isTwoHanded(type) {
        switch (type) {
            case 'Axe': return false;
            case 'Dagger': return false;
            case 'Mace': return false;
            case 'Pistol': return false;
            case 'Scepter': return false;
            case 'Focus': return false;
            case 'Sword': return false;
            case 'BowShort': return false;
            case 'Torch': return false;
            case 'Shield': return false;
            case 'Warhorn': return false;
            case 'Toy': return false;
            case 'ToyTwoHanded': return false;
            case 'BundleSmall': return false;
            case 'Hammer': return true;
            case 'BowLong': return true;
            case 'Greatsword': return true;
            case 'Polearm': return true;
            case 'Rifle': return true;
            case 'Staff': return true;
            case 'BundleLarge': return true;
            case 'Spear': return true;
            case 'Speargun': return true;
            case 'Trident': return true;
        }
    }
    const DEFAULT_CONTEXT = {
        gameMode: 'Pve',
        underwater: false,
        targetArmor: 2597,
        character: {
            level: 80,
            isPlayer: true,
            sex: "Male",
            traits: [],
            specializations: [],
            stats: {
                values: {
                    Power: 0,
                    Toughness: 0,
                    Vitality: 0,
                    Precision: 0,
                    Ferocity: 0,
                    ConditionDamage: 0,
                    Expertise: 0,
                    Concentration: 0,
                    HealingPower: 0,
                    AgonyResistance: 0,
                },
                sources: {
                    Power: [],
                    Toughness: [],
                    Vitality: [],
                    Precision: [],
                    Ferocity: [],
                    ConditionDamage: [],
                    Expertise: [],
                    Concentration: [],
                    HealingPower: [],
                    AgonyResistance: [],
                    Armor: [],
                    Damage: [],
                    LifeForce: [],
                    Health: [],
                    HealEffectiveness: [],
                    Stun: [],
                    ConditionDuration: [],
                    BoonDuration: [],
                    CritChance: [],
                    CritDamage: [],
                },
            },
            statsWithWeapons: [{
                    values: {
                        Power: 1000,
                        Toughness: 1000,
                        Vitality: 1000,
                        Precision: 1000,
                        Ferocity: 0,
                        ConditionDamage: 0,
                        Expertise: 0,
                        Concentration: 0,
                        HealingPower: 0,
                        AgonyResistance: 0,
                        Health: 10000,
                        Armor: 1000,
                        CritChance: 0.05,
                        CritDamage: 1.5,
                        ConditionDuration: 0,
                        BoonDuration: 0,
                    },
                    sources: {
                        Power: [],
                        Toughness: [],
                        Vitality: [],
                        Precision: [],
                        Ferocity: [],
                        ConditionDamage: [],
                        Expertise: [],
                        Concentration: [],
                        HealingPower: [],
                        AgonyResistance: [],
                        Armor: [],
                        Damage: [],
                        LifeForce: [],
                        Health: [],
                        HealEffectiveness: [],
                        Stun: [],
                        ConditionDuration: [],
                        BoonDuration: [],
                        CritChance: [],
                        CritDamage: [],
                    },
                    htmlParts: {
                        Power: [],
                        Toughness: [],
                        Vitality: [],
                        Precision: [],
                        Ferocity: [],
                        ConditionDamage: [],
                        Expertise: [],
                        Concentration: [],
                        HealingPower: [],
                        AgonyResistance: [],
                        Armor: [],
                        Health: [],
                        ConditionDuration: [],
                        BoonDuration: [],
                        CritChance: [],
                        CritDamage: [],
                    },
                }],
            selectedWeaponSet: 0,
            upgradeCounts: {},
        },
    };
    function createCompleteContext(partialContext) {
        var _a, _b, _c, _d, _e, _f;
        if (partialContext.gameMode == "Pvp" && ((_a = partialContext.character) === null || _a === void 0 ? void 0 : _a.level) && ((_b = partialContext.character) === null || _b === void 0 ? void 0 : _b.level) != 80) {
            console.error('[gw2-tooltips] [init] supplied (partial) context has its gamemode set to pvp, but has a character level specified thats other than 80. In pvp you are always level 80. This will lead to unexpected results; Remove the explicit level or change the gamemode. The (partial) context in question is: ', partialContext);
        }
        const stats = createCompletedBaseStats((_c = partialContext.character) === null || _c === void 0 ? void 0 : _c.stats);
        const upgradeCounts = Object.assign({}, (_d = partialContext.character) === null || _d === void 0 ? void 0 : _d.upgradeCounts);
        const statsWithWeapons = ((_f = (_e = partialContext.character) === null || _e === void 0 ? void 0 : _e.statsWithWeapons) === null || _f === void 0 ? void 0 : _f.map(s => createCompletedStats(s))) || [createCompletedStats()];
        const character = Object.assign({}, DEFAULT_CONTEXT.character, partialContext.character, { stats, upgradeCounts, statsWithWeapons, traits: [], specializations: [] });
        return Object.assign({}, DEFAULT_CONTEXT, partialContext, { character });
    }
    function createCompletedBaseStats(partialSource = {}) {
        const values = Object.assign({}, DEFAULT_CONTEXT.character.stats.values, partialSource.values);
        const sources = Object.assign({}, structuredClone(DEFAULT_CONTEXT.character.stats.sources), partialSource.sources);
        return { values, sources };
    }
    function createCompletedStats(partialSource = {}) {
        const values = Object.assign({}, DEFAULT_CONTEXT.character.statsWithWeapons[0].values, partialSource.values);
        const sources = Object.assign({}, structuredClone(DEFAULT_CONTEXT.character.statsWithWeapons[0].sources), partialSource.sources);
        const htmlParts = Object.assign({}, structuredClone(DEFAULT_CONTEXT.character.statsWithWeapons[0].htmlParts), partialSource.htmlParts);
        return { values, sources, htmlParts };
    }
    const DEFAULT_CONFIG = {
        autoInitialize: true,
        autoCollectRuneCounts: true,
        autoCollectStatSources: true,
        autoCollectSelectedTraits: true,
        autoRecomputeCharacterAttributes: true,
        adjustIncorrectStatIds: true,
        autoInferEquipmentUpgrades: true,
        autoInferWeaponSetAssociation: true,
        legacyCompatibility: true,
        showPreciseAbilityTimings: false,
        showFactComputationDetail: false,
    };
    var Rarity;
    (function (Rarity) {
        Rarity[Rarity["Junk"] = 0] = "Junk";
        Rarity[Rarity["Basic"] = 1] = "Basic";
        Rarity[Rarity["Common"] = 2] = "Common";
        Rarity[Rarity["Uncommon"] = 3] = "Uncommon";
        Rarity[Rarity["Rare"] = 4] = "Rare";
        Rarity[Rarity["Exotic"] = 5] = "Exotic";
        Rarity[Rarity["Ascended"] = 6] = "Ascended";
        Rarity[Rarity["Legendary"] = 7] = "Legendary";
    })(Rarity || (Rarity = {}));
    const LUT_RARITY = [0, 0, 1, 2, 3, 4, 4, 4];
    const LUT_RARITY_MUL = [0.5, 0.65, 0.8, 0.85, 0.9, 1.0, 1.05, 1.05];
    const ICONS = {
        COIN_COPPER: 156902,
        COIN_SILVER: 156907,
        COIN_GOLD: 156904,
        SLOT_Upgrade: 517197,
        SLOT_Infusion: 517202,
        SLOT_Enrichment: 517204,
        RESOURCE_THIEF: 156649,
        RESOURCE_REV: 156647,
        UPKEEP_COST: 156058,
        SUPPLY_COST: 2111003,
        ENDURANCE_COST: 156649,
        NO_UNDERWATER: 358417,
        RECHARGE: 156651,
        ACTIVATION: 496252,
        RANGE: 156666,
        DEFIANCE_BREAK: 1938788,
        WEAPON_SWAP: 156583,
        BARRIER: 1770209,
        STUN_BREAK: 156654,
        KNOCKDOWN: 2440716,
        PULL: 2440717,
        KNOCKBACK: 2440715,
        LAUNCH: 2440712,
        FLOAT: 2440713,
        SINK: 2440714,
    };
    const VALID_CHAIN_PALETTES = ['Bundle', 'Heal', 'Elite', 'Profession', 'Standard', 'Equipment'];
    _constructor();
    if (exports.config.autoInitialize) {
        const buildNodes = document.getElementsByClassName('gw2-build-wrapper');
        if (exports.config.autoCollectSelectedTraits) {
            if (buildNodes.length)
                for (const target of buildNodes)
                    allTraits(target);
            else {
                console.warn("[gw2-tooltips] [collect] `config.autoCollectSelectedTraits` is active, but no element with class `gw2-build` could be found to use as source. Build information will not be collected as there is no way to tell which objects belong to the build definition and which ones are just in some arbitrary text.");
            }
        }
        hookDocument(document)
            .then(gw2Objects => {
            var _a;
            if (exports.config.autoInferWeaponSetAssociation) {
                for (const buildNode of buildNodes) {
                    for (const [i, setNode] of buildNode.querySelectorAll('.weapon-set').entries()) {
                        for (const objNode of setNode.getElementsByTagName('GW2OBJECT'))
                            objNode.setAttribute('weaponSet', String(i));
                    }
                    const skillIdsBySet = [];
                    for (const [i, setSkillsNode] of buildNode.querySelectorAll('.skills-weapon-set').entries()) {
                        const skillIds = [];
                        const chainIds = (skill, context, adjustTraitedSkillIds) => {
                            if (adjustTraitedSkillIds) {
                                const replacementSkill = findTraitedOverride(skill, context);
                                if (replacementSkill)
                                    skill = replacementSkill;
                            }
                            skillIds.push(skill.id);
                            let group, i;
                            [group, i, context] = findMostLikelyGroupAndContext(skill, context);
                            if (group) {
                                let candidate = group.candidates[i];
                                while (candidate.previous_chain_skill_index) {
                                    const otherCandidate = group.candidates[candidate.previous_chain_skill_index];
                                    if (!canBeSelected(otherCandidate, context))
                                        break;
                                    skillIds.push(otherCandidate.skill);
                                    candidate = otherCandidate;
                                }
                                for (let j = 0; j < i; j++) {
                                    const otherCandidate = group.candidates[j];
                                    if (otherCandidate.previous_chain_skill_index != i)
                                        continue;
                                    if (!canBeSelected(otherCandidate, context))
                                        continue;
                                    skillIds.push(otherCandidate.skill);
                                    i = j;
                                    j = -1;
                                }
                            }
                            if (skill.bundle_skills)
                                for (const subSkillId of skill.bundle_skills) {
                                    const subSkillInChain = APICache.storage.skills.get(subSkillId);
                                    if (subSkillInChain)
                                        skillIds.push(subSkillId);
                                }
                            if (skill.related_skills)
                                for (const subSkillId of skill.related_skills) {
                                    const subSkillInChain = APICache.storage.skills.get(subSkillId);
                                    if (subSkillInChain && subSkillInChain.palettes.some(pid => {
                                        const palette = APICache.storage.palettes.get(pid);
                                        return palette && VALID_CHAIN_PALETTES.includes(palette.type);
                                    })) {
                                        skillIds.push(subSkillId);
                                    }
                                }
                            if (skill.ambush_skills)
                                for (const { id: subSkillId } of skill.ambush_skills) {
                                    const subSkillInChain = APICache.storage.skills.get(subSkillId);
                                    if (subSkillInChain)
                                        skillIds.push(subSkillId);
                                }
                        };
                        for (const objNode of setSkillsNode.children) {
                            objNode.setAttribute('weaponSet', String(i));
                            const skill = APICache.storage.skills.get(+String(objNode.getAttribute('objid')));
                            const context = contexts[+String(objNode.getAttribute('contextSet')) || 0];
                            const adjustTraitedSkillIds = objNode.classList.contains('auto-transform');
                            if (skill)
                                chainIds(skill, context, adjustTraitedSkillIds);
                            else {
                                console.warn("[gw2-tooltips] [collect] failed to find skill for object ", objNode);
                            }
                        }
                        skillIdsBySet.push(skillIds);
                    }
                    if (skillIdsBySet.length > 1 && (skillIdsBySet[0][0] != skillIdsBySet[1][0] || skillIdsBySet[0][skillIdsBySet[0].length - 1] != skillIdsBySet[1][skillIdsBySet[1].length - 1])) {
                        console.info("[gw2-tooltips] [collect] Will mark the following skills as belonging to weapon sets: ", skillIdsBySet);
                        const descriptionNode = (_a = buildNode.parentElement.nextElementSibling) === null || _a === void 0 ? void 0 : _a.nextElementSibling;
                        if (descriptionNode)
                            for (const skillNode of descriptionNode.querySelectorAll('gw2object[type=skill]')) {
                                const id = +String(skillNode.getAttribute('objid')) || 0;
                                if (id)
                                    for (const [i, skills] of skillIdsBySet.entries()) {
                                        if (skills.includes(id))
                                            skillNode.setAttribute('weaponSet', String(i));
                                    }
                            }
                    }
                }
            }
            if (exports.config.autoCollectRuneCounts) {
                if (buildNodes.length)
                    for (const target of buildNodes)
                        allUpgradeCounts(target);
                else {
                    console.warn("[gw2-tooltips] [collect] `config.autoCollectRuneCounts` is active, but no element with class `gw2-build` could be found to use as source. Upgrades will not be collected as there is no way to tell which upgrades belongs to the build and which ones are just in some arbitrary text.");
                }
            }
            if (exports.config.autoCollectStatSources) {
                if (buildNodes.length)
                    for (const target of buildNodes)
                        allStatSources(target);
                else {
                    console.warn("[gw2-tooltips] [collect] `config.autoCollectStatSources` is active, but no element with class `gw2-build` could be found to use as source. Build information will not be collected as there is no way to tell which objects belong to the build definition and which ones are just in some arbitrary text.");
                }
            }
            if (exports.config.autoCollectSelectedTraits) {
                traitEffects(contexts);
            }
            if (exports.config.autoInferEquipmentUpgrades) {
                const targets = document.querySelectorAll('.weapon, .armor, .trinket');
                if (targets.length)
                    inferItemUpgrades(targets);
                else {
                    console.warn("[gw2-tooltips] [collect] `config.autoInferEquipmentUpgrades` is active, but no wrapper elements element with class `'weapon`, `armor` or `trinket` could be found to use as source. No elements will be updated");
                }
            }
            if (exports.config.autoRecomputeCharacterAttributes) {
                for (const context of contexts) {
                    for (const weaponSetId of context.character.statsWithWeapons.keys()) {
                        recomputeAttributesFromMods(context, weaponSetId);
                    }
                }
            }
            for (const [attribute, elements] of gw2Objects.attributes) {
                for (const element of elements) {
                    inflateAttribute(element, attribute);
                }
            }
        });
    }

    exports.DEFAULT_CONTEXT = DEFAULT_CONTEXT;
    exports.ICONS = ICONS;
    exports.attachMouseListeners = attachMouseListeners;
    exports.contexts = contexts;
    exports.createCompletedBaseStats = createCompletedBaseStats;
    exports.createCompletedStats = createCompletedStats;
    exports.findCorrectAttributeSet = findCorrectAttributeSet;
    exports.findTraitedOverride = findTraitedOverride;
    exports.formatItemName = formatItemName;
    exports.hookDocument = hookDocument;
    exports.resolveTraitsAndOverrides = resolveTraitsAndOverrides;
    exports.specializeContextFromInlineAttribs = specializeContextFromInlineAttribs;

    return exports;

})({});
//# sourceMappingURL=tooltips.min.js.map
